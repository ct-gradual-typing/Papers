import Fix;

tail : forall (X<:*).([X] -> [X])
tail = \(X<:*) -> \(l:[X]) ->
             case l of [] -> [X][], (h :: t) -> t;

map : forall (A <: Simple).(forall (B <: Simple).((A -> B) -> ([A] -> [B])))
map = \(A <: Simple) -> \(B <: Simple) -> \(f : A -> B) ->
        ([[A] -> [B]]fixp)
           (\(r : [A] -> [B]) -> \(l : [A]) ->
                   case l of
                     [] -> [B][],
                     (x :: xs) -> (f x) :: (r xs));

foldr : forall (A <: Simple).(forall (B <: Simple).((A -> B -> B) -> B -> ([A] -> B)))
foldr = \(A <: Simple) -> \(B <: Simple) -> \(f : A -> B -> B) -> \(b : B) ->
          ([[A] -> B]fixp)
            (\(r : [A] -> B) -> \(l : [A]) ->
                   case l of
                     [] -> b,
                     (a :: as) -> (f a (r as)));

foldl : forall (A <: Simple).(forall (B <: Simple).((B -> A -> B) -> (B -> [A] -> B)))
foldl = \(A <: Simple) -> \(B <: Simple) -> \(f : B -> A -> B) ->
          ([B -> [A] -> B]fixp)
            (\(r : B -> [A] -> B) -> \(b : B) -> \(l : [A]) ->
                   case l of
                     [] -> b,
                     (a :: as) -> r (f b a) as);

reverse : forall (A <: Simple).([A] -> [A])
reverse = \(A <: Simple) -> \(l : [A]) -> ([[A]][A]foldl) (\(acc:[A]) -> \(x:A) -> x :: acc) [] l;

zipWith : forall (A <: Simple).(forall (B <: Simple).(forall (C <: Simple).((A -> B -> C) -> ([A] -> [B] -> [C]))))
zipWith = \(A <: Simple) -> \(B <: Simple) -> \(C <: Simple) -> \(f : A -> B -> C) ->
            ([[A] -> [B] -> [C]]fixp)
              (\(r : [A] -> [B] -> [C]) -> \(l1 : [A]) -> \(l2 : [B]) ->
                 case l1 of
                   [] -> [C][],
                   (a :: as) -> case l2 of
                                  [] -> [C][],
                                  (b :: bs) -> (f a b) :: (r as bs));