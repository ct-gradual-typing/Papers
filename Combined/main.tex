\documentclass[sigplan]{acmart}\settopmatter{printfolios=true}

\setcopyright{none}

\usepackage{amssymb,amsmath, amsthm}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{mathpartir}
\usepackage[barr]{xy}
\usepackage{mdframed}
\usepackage{supertabular}
\usepackage{todonotes}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{color}

%% From: https://hal.inria.fr/file/index/docid/881085/filename/lsthaskell.sty
\lstdefinelanguage{Haskell}{ 
  %
  % Anything betweeen $ becomes LaTeX math mode
  mathescape=true,
  %
  % Comments may or not include Latex commands
  texcl=false, 
  %
  morekeywords=[1]{class, instance},
  %
  morekeywords=[2]{where},
  %
  morekeywords=[3]{Maybe},
  %
  morekeywords=[4]{main},
  %
  morekeywords=[6]{do, last, first, try, idtac, repeat},
  %
  % Comments delimiters, we do turn this off for the manual
  morecomment=[s]{(*}{*)},
  %
  % Spaces are not displayed as a special character
  showstringspaces=false,
  %
  % String delimiters
  morestring=[b]",
  morestring=[d]Â’,
  %
  % Size of tabulations
  tabsize=3,
  %
  % Enables ASCII chars 128 to 255
  extendedchars=false,
  %
  % Case sensitivity
  sensitive=true,
  %
  % Automatic breaking of long lines
  breaklines=false,
  %
  % Default style fors listings
  basicstyle=\scriptsize,
  %
  % Position of captions is bottom
  captionpos=b,
  %
  % flexible columns
  columns=[l]flexible,
  %
  % Style for (listings') identifiers
  identifierstyle={\ttfamily\color{black}},
  % Style for declaration keywords
  keywordstyle=[1]{\ttfamily\color{dkviolet}},
  % Style for gallina keywords
  keywordstyle=[2]{\ttfamily\color{dkgreen}},
  % Style for sorts keywords
  keywordstyle=[3]{\ttfamily\color{ltblue}},
  % Style for tactics keywords
  keywordstyle=[4]{\ttfamily\color{dkblue}},
  % Style for terminators keywords
  keywordstyle=[5]{\ttfamily\color{dkred}},
  %Style for iterators
  %keywordstyle=[6]{\ttfamily\color{dkpink}},
  % Style for strings
  stringstyle=\ttfamily,
  % Style for comments
  commentstyle={\ttfamily\color{dkgreen}},
  %
  %moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
  literate=
  {->}{{$\rightarrow\;$}}1
  {=>}{{$\Rightarrow\;$}}1
  {<:}{{$<\hspace{-2px}\colon$}}1
  {++}{{\code{++}}}1
  {\{}{{$\langle$}}1
  {\}}{{$\rangle\;$}}1
  {~}{{\ }}1
  {\\dollar}{{$\$$\;}}1
  %
}[keywords,comments,strings]

\lstnewenvironment{haskell}{\lstset{language=Haskell}}{}

% pour inliner dans le texte
\def\hasqel{\lstinline[language=Haskell, basicstyle=\small]}
% pour inliner dans les tableaux / displaymath...
\def\haskels{\lstinline[language=Haskell, basicstyle=\scriptsize]}

\newenvironment{enumR}{\begin{enumerate}[label=\roman*.,align=left]}{\end{enumerate}}
\newenvironment{enumA}{\begin{enumerate}[label=\alph*.]}{\end{enumerate}}

\newcommand{\cL}{{\cal L}}

\let\mto\to                     % Used for arrows
\let\to\relax                   % Used for implication
\newcommand{\to}{\rightarrow}
\newcommand{\id}{\mathsf{id}}
\newcommand{\redto}{\rightsquigarrow}
\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\catop}[1]{\mathcal{#1}^{\mathsf{op}}}
\newcommand{\Case}[0]{\mathsf{case}}

\let\split\relax
\let\S\relax

\newcommand{\split}[0]{\mathsf{split}}
\newcommand{\squash}[0]{\mathsf{squash}}
\newcommand{\bx}[0]{\mathsf{box}}
\newcommand{\error}[0]{\mathsf{error}}
\newcommand{\err}[0]{\mathsf{err}}
\newcommand{\unbox}[0]{\mathsf{unbox}}
\newcommand{\T}[0]{\mathsf{T}}
\newcommand{\S}[0]{\mathsf{S}}
\newcommand{\U}[0]{\mathsf{U}}
\newcommand{\C}[0]{\mathsf{C}}
\newcommand{\z}[0]{\mathsf{z}}
\newcommand{\app}[0]{\mathsf{app}}
\newcommand{\curry}[1]{\mathsf{curry}(#1)}
\newcommand{\interp}[1]{[\negthinspace[#1]\negthinspace]}
\newcommand{\Hom}[3]{\mathsf{Hom}_{\cat{#1}}(#2,#3)}

%% \newtheorem{theorem}{Theorem}
%% \newtheorem{lemma}[theorem]{Lemma}
%% \newtheorem{corollary}[theorem]{Corollary}
%% \newtheorem{definition}[theorem]{Definition}
%% \newtheorem{proposition}[theorem]{Proposition}
%% \newtheorem{example}[theorem]{Example}

%% OTT Includes:
\input{surface-grady-inc}
\renewcommand{\SGradydrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\,\SGradydrulename{#4}}}
\renewcommand{\SGradydrulename}[1]{#1}

\renewcommand{\SGradydruleSXXReflName}{\text{refl}}
\renewcommand{\SGradydruleSXXVarName}{\text{var}}
\renewcommand{\SGradydruleSXXBoxName}{\mathsf{box}}
\renewcommand{\SGradydruleSXXUnboxName}{\mathsf{unbox}}
\renewcommand{\SGradydruleSXXUSLName}{?_\mathcal{S}}
\renewcommand{\SGradydruleSXXTopSLName}{\top_\mathcal{S}}
\renewcommand{\SGradydruleSXXListName}{\mathsf{List}}
\renewcommand{\SGradydruleSXXProdName}{\times}
\renewcommand{\SGradydruleSXXArrowName}{\to}
\renewcommand{\SGradydruleSXXForallName}{\forall}
\renewcommand{\SGradydruleSXXTopName}{\text{top}}
\renewcommand{\SGradydruleSXXNatSLName}{\mathsf{Nat}_\mathcal{S}}
\renewcommand{\SGradydruleSXXUnitSLName}{\mathsf{Unit}_\mathcal{S}}
\renewcommand{\SGradydruleSXXListSLName}{\mathsf{List}_\mathcal{S}}
\renewcommand{\SGradydruleSXXArrowSLName}{\to_\mathcal{S}}
\renewcommand{\SGradydruleSXXProdSLName}{\times_\mathcal{S}}

\renewcommand{\SGradydruleCXXReflName}{\text{refl}}
\renewcommand{\SGradydruleCXXBoxName}{\mathsf{box}}
\renewcommand{\SGradydruleCXXUnboxName}{\mathsf{unbox}}
\renewcommand{\SGradydruleCXXListName}{\mathsf{List}}
\renewcommand{\SGradydruleCXXArrowName}{\to}
\renewcommand{\SGradydruleCXXProdName}{\times}
\renewcommand{\SGradydruleCXXForallName}{\forall}

\renewcommand{\SGradydruleTXXboxName}{\mathsf{box}}
\renewcommand{\SGradydruleTXXunboxName}{\mathsf{unbox}}
\renewcommand{\SGradydruleTXXsplitName}{\mathsf{split}}
\renewcommand{\SGradydruleTXXsquashName}{\mathsf{squash}}
\renewcommand{\SGradydruleTXXvarPName}{\text{var}}
\renewcommand{\SGradydruleTXXunitPName}{\mathsf{Unit}}
\renewcommand{\SGradydruleTXXzeroPName}{\mathsf{zero}}
\renewcommand{\SGradydruleTXXsuccName}{\mathsf{succ}}
\renewcommand{\SGradydruleTXXncaseName}{\mathsf{Nat}_e}
\renewcommand{\SGradydruleTXXemptyName}{\text{empty}}
\renewcommand{\SGradydruleTXXconsName}{\mathsf{List}_i}
\renewcommand{\SGradydruleTXXlcaseName}{\mathsf{List}_e}
\renewcommand{\SGradydruleTXXpairName}{\times_i}
\renewcommand{\SGradydruleTXXfstName}{\times_{e_1}}
\renewcommand{\SGradydruleTXXsndName}{\times_{e_2}}
\renewcommand{\SGradydruleTXXlamName}{\to_i}
\renewcommand{\SGradydruleTXXappName}{\to_e}
\renewcommand{\SGradydruleTXXLamName}{\forall_i}
\renewcommand{\SGradydruleTXXtypeAppName}{\forall_e}
\renewcommand{\SGradydruleTXXSubName}{\text{sub}}

\renewcommand{\SGradydruleciXXvarName}{}
\renewcommand{\SGradydruleciXXzeroName}{}
\renewcommand{\SGradydruleciXXtrivName}{}
\renewcommand{\SGradydruleciXXsuccUName}{}
\renewcommand{\SGradydruleciXXsuccName}{}
\renewcommand{\SGradydruleciXXncaseUName}{}
\renewcommand{\SGradydruleciXXncaseName}{}
\renewcommand{\SGradydruleciXXpairName}{}
\renewcommand{\SGradydruleciXXfstUName}{}
\renewcommand{\SGradydruleciXXfstName}{}
\renewcommand{\SGradydruleciXXsndUName}{}
\renewcommand{\SGradydruleciXXsndName}{}
\renewcommand{\SGradydruleciXXEmptyName}{}
\renewcommand{\SGradydruleciXXconsName}{}
\renewcommand{\SGradydruleciXXlcaseUName}{}
\renewcommand{\SGradydruleciXXlcaseName}{}
\renewcommand{\SGradydruleciXXlamName}{}
\renewcommand{\SGradydruleciXXappUName}{}
\renewcommand{\SGradydruleciXXappName}{}
\renewcommand{\SGradydruleciXXLamName}{}
\renewcommand{\SGradydruleciXXtypeAppName}{}

\renewcommand{\SGradydrulePXXUName}{?}
\renewcommand{\SGradydrulePXXreflName}{\text{refl}}
\renewcommand{\SGradydrulePXXarrowName}{\to}
\renewcommand{\SGradydrulePXXprodName}{\times}
\renewcommand{\SGradydrulePXXlistName}{\mathsf{List}}
\renewcommand{\SGradydrulePXXforallName}{\forall}

\renewcommand{\SGradydruleTPXXreflName}{\text{refl}}
\renewcommand{\SGradydruleTPXXsuccName}{\mathsf{succ}}
\renewcommand{\SGradydruleTPXXNateName}{\mathsf{Nat}}
\renewcommand{\SGradydruleTPXXpairName}{\times_i}
\renewcommand{\SGradydruleTPXXfstName}{\times_{e_1}}
\renewcommand{\SGradydruleTPXXsndName}{\times_{e_2}}
\renewcommand{\SGradydruleTPXXconsName}{\mathsf{List}_i}
\renewcommand{\SGradydruleTPXXListeName}{\mathsf{List}_e}
\renewcommand{\SGradydruleTPXXFunName}{\to_i}
\renewcommand{\SGradydruleTPXXappName}{\to_2}
\renewcommand{\SGradydruleTPXXtfunName}{\forall_i}
\renewcommand{\SGradydruleTPXXtappName}{\forall_e}

\input{core-grady-inc}
\renewcommand{\CGradydruleSXXReflName}{\text{refl}}
\renewcommand{\CGradydruleSXXTopName}{\text{top}}
\renewcommand{\CGradydruleSXXVarName}{\text{var}}
\renewcommand{\CGradydruleSXXTopSLName}{\top_{\mathcal{S}}}
\renewcommand{\CGradydruleSXXNatSLName}{\mathsf{Nat}_{\mathcal{S}}}
\renewcommand{\CGradydruleSXXUnitSLName}{\mathsf{Unit}_{\mathcal{S}}}
\renewcommand{\CGradydruleSXXListSLName}{\mathsf{List}_{\mathcal{S}}}
\renewcommand{\CGradydruleSXXArrowSLName}{\to_{\mathcal{S}}}
\renewcommand{\CGradydruleSXXProdSLName}{\times_{\mathcal{S}}}
\renewcommand{\CGradydruleSXXListName}{\mathsf{List}}
\renewcommand{\CGradydruleSXXProdName}{\times}
\renewcommand{\CGradydruleSXXArrowName}{\to}
\renewcommand{\CGradydruleSXXForallName}{\forall}

\renewcommand{\CGradydrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\CGradydrulename{#4}}}
\renewcommand{\CGradydrulename}[1]{#1}
\renewcommand{\CGradydruleTXXvarPName}{\text{var}}
\renewcommand{\CGradydruleTXXvarName}{\text{var}}
\renewcommand{\CGradydruleTXXBoxName}{\mathsf{box}}
\renewcommand{\CGradydruleTXXUnboxName}{\mathsf{unbox}}
\renewcommand{\CGradydruleTXXsquashName}{\mathsf{squash}}
\renewcommand{\CGradydruleTXXsplitName}{\mathsf{split}}
\renewcommand{\CGradydruleTXXunitPName}{\mathsf{Unit}}
\renewcommand{\CGradydruleTXXzeroPName}{\text{zero}}
\renewcommand{\CGradydruleTXXsuccName}{\mathsf{succ}}
\renewcommand{\CGradydruleTXXncaseName}{\mathsf{Nat}_e}
\renewcommand{\CGradydruleTXXemptyName}{\text{empty}}
\renewcommand{\CGradydruleTXXconsName}{\mathsf{List}_i}
\renewcommand{\CGradydruleTXXlcaseName}{\mathsf{List}_e}
\renewcommand{\CGradydruleTXXpairName}{\times_i}
\renewcommand{\CGradydruleTXXfstName}{\times_{e_1}}
\renewcommand{\CGradydruleTXXsndName}{\times_{e_2}}
\renewcommand{\CGradydruleTXXlamName}{\to_i}
\renewcommand{\CGradydruleTXXappName}{\to_e}
\renewcommand{\CGradydruleTXXLamName}{\forall_i}
\renewcommand{\CGradydruleTXXtypeAppName}{\forall_e}
\renewcommand{\CGradydruleTXXSubName}{\text{sub}}
\renewcommand{\CGradydruleTXXerrorName}{\text{error}}

\renewcommand{\CGradydrulerdXXretracTName}{\text{retract}}
\renewcommand{\CGradydrulerdXXretracTEName}{\text{error}}
\renewcommand{\CGradydrulerdXXretractUName}{\text{retract}_2}
\renewcommand{\CGradydrulerdXXncaseZeroName}{\mathsf{Nat}_{e_1}}
\renewcommand{\CGradydrulerdXXncaseSuccName}{\mathsf{Nat}_{e_2}}
\renewcommand{\CGradydrulerdXXncaseName}{\text{ce}}
\renewcommand{\CGradydrulerdXXlcaseEmptyName}{\mathsf{List}_{e_1}}
\renewcommand{\CGradydrulerdXXlcaseConsName}{\mathsf{List}_{e_2}}
\renewcommand{\CGradydrulerdXXheadName}{}
\renewcommand{\CGradydrulerdXXtailName}{}
\renewcommand{\CGradydrulerdXXlcaseName}{}
\renewcommand{\CGradydrulerdXXbetaName}{\beta}
\renewcommand{\CGradydrulerdXXprojOneName}{\times_{e_1}}
\renewcommand{\CGradydrulerdXXprojTwoName}{\times_{e_2}}
\renewcommand{\CGradydrulerdXXappName}{\text{app}_1}
\renewcommand{\CGradydrulerdXXappTwoName}{\text{app}_2}
\renewcommand{\CGradydrulerdXXsplitName}{\mathsf{split}}
\renewcommand{\CGradydrulerdXXsuccName}{\mathsf{succ}}
\renewcommand{\CGradydrulerdXXunboxName}{\mathsf{unbox}}
\renewcommand{\CGradydrulerdXXfstName}{\mathsf{fst}}
\renewcommand{\CGradydrulerdXXsndName}{\mathsf{snd}}
\renewcommand{\CGradydrulerdXXpairOneName}{\text{pair}_1}
\renewcommand{\CGradydrulerdXXpairTwoName}{\text{pair}_2}
\renewcommand{\CGradydrulerdXXtypeBetaName}{\text{type}_{\beta}}
\renewcommand{\CGradydrulerdXXtypeAppName}{}

\renewcommand{\CGradydruleTPXXunboxingName}{\mathsf{box}}
\renewcommand{\CGradydruleTPXXboxingName}{\mathsf{unbox}}
\renewcommand{\CGradydruleTPXXsplitingName}{\mathsf{split}}
\renewcommand{\CGradydruleTPXXsquashingName}{\mathsf{squash}}
\renewcommand{\CGradydruleTPXXerrorName}{\mathsf{error}}

\renewcommand{\CGradydruleCtxPXXreflName}{\text{refl}}
\renewcommand{\CGradydruleCtxPXXextName}{\text{ext}}

\newenvironment{ack}{\textbf{Acknowledgments.}}{}

\begin{document}

\title{The Combination of Dynamic and Static Typing from a Categorical Perspective}
\author{Harley Eades III}
\affiliation{
  \department{Computer Science}              %% \department is recommended
  \institution{Augusta University}            %% \institution is required
  \city{Augusta}
  \state{GA}
  \country{USA}
}
\email{harley.eades@gmail.com}          %% \email is recommended

\author{Michael Townsend}
\affiliation{
  \department{Computer Science}              %% \department is recommended
  \institution{Augusta University}            %% \institution is required
  \city{Augusta}
  \state{GA}
  \country{USA}
}
\email{mitownsend@augusta.edu}          %% \email is recommended

\thanks{Both authors where supported by the National Science
  Foundation CRII CISE Research Initiation grant, ``CRII:SHF: A New
  Foundation for Attack Trees Based on Monoidal Categories``, under
  Grant No. 1565557.}

%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code

\keywords{  
    static typing, dynamic typing, gradual typing, categorical
    semantics, retract,typed lambda-calculus, untyped lambda-calculus,
    functional programming, bounded quantification}

\begin{abstract} 
  In this paper we introduce a new categorical model based on retracts
  that combines static and dynamic typing.  This model is initially
  based on the seminal work of Scott who showed that the untyped
  $\lambda$-calculus can be considered as typed using retracts.
  Following this we define a new simple type system which combines
  static and dynamic typing called Grady that corresponds to our
  model.  Then we develop a gradually typed surface language for
  Grady, and show that it can be translated into Grady such that the
  gradual guarantee holds.  Finally, to illustrate how this system can
  be extended with new features we extend both the surface and the
  core languages with bounded quantification such that the gradual
  guarantee is preserved.
\end{abstract}

\maketitle

\section{Introduction}
\label{sec:introduction}
%% \input{introduction-ott}
% section introduction (end)

\section{The Categorical Model}
\label{subsec:the_categorical_model}
\input{categorical-model-ott}
% section the_interpretation (end)

\section{Core Grady}
\label{sec:core_grady}
\input{core-grady-ott}
% section core_grady (end)

\section{Surface Grady}
\label{sec:surface_grady}
\input{surface-grady-ott}
% section surface_grady (end)

\section{The Gradual Guarantee}
\label{sec:the_gradual_guarantee}
\input{gradual-guarantee-ott}
% section the_gradual_guarantee (end)

\section{Bounded Quantification}
\label{sec:bounded_quantification}
\input{bounded-ott}
% section bounded_quantification (end)

\section{Related Work}
\label{sec:related_work}

% section related_work (end)


\section{Future Work}
\label{sec:conclusion}
%% \input{conclusion}
% section conclusion (end)

\nocite{*}
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\appendix

\input{proofs-ott}

% section proofs (end)
\end{document}
