%% The problem:
%%   Not many mathematical models of gradual type systems especially categorical models.
%% Model gives us:
%%   - Connects existing work to gradual typing and the combination of dynamic and static typing
%%   - Can lead to simplifications of the language design: Core Grady does not depend on type consistency
%%   - A categorical model will help in the design of more powerful
%%     gradual type systems, for example, linear types, effects, polymorphism, dependent types, etc.

Gradual typing \cite{Siek:2006,Siek:2015} is a way to combine static
and dynamic typing within the same language.  For example, one can
structure their programs so that the safety critical parts are as
statically typed as possible to catch the most errors at compile time,
while rapidly prototyping other parts of their program using dynamic
typing.

The design of a gradual type system consists of two languages: a core
language and a surface language.  Both languages start as a static
type system with a new type called the unknown type, denoted in this
paper by $[[?]]$, whose inhabitants are all untyped programs.  The
core language then has an explicit mechanism for casting types to and
from the unknown type, and an operational semantics.  However, the
surface language only consists of a type checking algorithm that is
designed so that casts are left implicit, and then after type checking
succeeds a surface language program is translated into the core
language by a cast insertion algorithm.

Programming in the surface language requires the ability to implicitly
cast data between consistent types during eliminations. For example,
$[[(\x:?.(succ (succ x))) 3]]$ should type check with type $[[Nat]]$
even though $[[3]]$ has type $[[Nat]]$ and $[[x]]$ has type
$[[?]]$. Now not every cast should work, for example, $[[(\x:Bool.t)
    3]]$ should not type check, because it is inconsistent to allow
different atomic types to be cast between each other.  Therefore, the
surface language must be able to decide which casts are consistent and
which are not.  This is done by extending the type checking algorithm
with a binary relation called \emph{type consistency} which determines
which types are castable between each other, e.g. every type will be
consistent with the unknown type.

Just as Siek et al. report \cite{Siek:2006,Siek:2007,Siek:2015} there
are a number of programming languages that combine static and dynamic
typing with implicit casting to and from the unknown type, for
example, Boo \cite{?}, Bigloo \cite{?,?}, Cecil \cite{?}, extensions
of Visual Basic .Net, C\#, and Java \cite{?,?}, Professor J \cite{?},
and many more.  In addition, there are languages that combine static
and dynamic typing with explicit casting only. Abadi et
al.~\cite{Abadi:1989} combine dynamic and static typing by adding a
new type called $\mathsf{Dynamic}$ along with a new case construct for
pattern matching on types, and Henglein~\cite{Henglein:1994} defines
the dynamic $\lambda$-calculus by adding a new type $\mathsf{Dyn}$ to
the simply typed $\lambda$-calculus and then adding primitive casting
operations called tagging and check-and-untag. Please see the
introduction to Siek et al.~\cite{Siek:2015} for a more complete
list. However, not every language that combines static and dynamic
typing corresponds to a gradual type system.

Every gradual type system must satisfy the metatheoretic property
called the \emph{gradual guarantee}.  The gradual guarantee states the
following:
\begin{itemize}
\item Adding or removing casts to/from any well-typed surface language
  program remains typeable at a potentially less precise type.
\item Adding explicit casts to a terminating well-typed core language
  program also terminates at a related value, adding explicit casts to
  a diverging well-typed core language program diverges, and removing
  explicit casts from a terminating or diverging well-type core
  language programs either terminates, diverges, or raises a dynamic
  type error.
\end{itemize}
Briefly, the gradual guarantee states that any well-typed program can
slide between being more statically typed or being more dynamically
typed by inserting or removing casts without changing the meaning or
the behavior of the program. The formal statement of the gradual
guarantee is given in Section~\ref{sec:the_gradual_guarantee}.  This
property was first proposed by Siek et al.~\cite{Siek:2015} to set
apart systems that simply combine dynamic and static typing and
gradual type systems.

Expanding gradual type systems with new features is an increasingly
important line of research \cite{Siek:2006,Siek:2007,Garcia:2016,
  Lehmann:2017:GRT:3009837.3009856,
  Jafery:2017:SUR:3093333.3009865}\footnote{There are even more
  examples in the list of accepted papers for ICFP 2017, for example,
  extending gradual type systems with session types and
  polymorphism.}.  However, there are no categorical models, in fact,
not many mathematical models at all to aid in the design of new
gradual type systems.

One strength and main motivation for giving a categorical model to a
programming language is that it can expose the fundamental structure
of the language.  This arises because a lot of the language features
that often cloud the picture go away, for example, syntactic notions
like variables disappear.  This can often simplify things and expose
the underlying structure.  For example, when giving the simply typed
$\lambda$-calculus a categorical model we see that it is a cartesian
closed category, but we also know that intuitionistic logic has the
same model due to Lambek~\cite{Lambek:1980}; on the syntactic side
these two theories are equivalent as well due to
Howard~\cite{Howard:1980}; this is known as the Curry-Howard-Lambek
correspondence.

The previous point highlights one of the most powerful features of
category theory: its ability to relate seemingly unrelated theories.
It is quite surprising that the typed $\lambda$-calculus and
intuitionistic logic share the same model.  Thus, defining a
categorical model for a particular programming language may reveal new
and interesting relationships with existing work.  In fact, one of the
contributions of this paper is the new connection between Scott and
Lambek's work to the new area of gradual typing and combing static and
dynamic typing.

However, that motivation places defining a categorical model as an
after thought.  The programming languages developed here were designed
from the other way around.  We started with the question, how do we
combine static and dynamic typing categorically? Then after developing
the model we use it to push us toward the correct language design.
Reynolds \cite{Brookes:2013} was a big advocate for the use of
category theory in programming language research for this reason.  We
think the following quote -- reported by Brookes et
al.~\cite{Brookes:2013} -- makes this point nicely:
\begin{center}
  \parbox{170pt}{
    \emph{Programming language semanticists should be the obstetricians
    of programming languages, not their coroners.\\
    {\rightline{--- John C. Reynolds}}}}
\end{center}

Categorical semantics provides a powerful tool to study language
extensions.  For example, purely functional programming in Haskell
would not be where it is without the seminal work of Moggi and Wadler
\cite{Moggi:1989,Wadler:1995} on using monads -- a purely categorical
notion -- to add side effects to to pure functional programming
languages.  Thus, we believe that developing these types of models for
new language designs and features can be hugely beneficial.

In this paper we propose a new categorical model of the core casting
calculus of gradual type systems based on the seminal work of
Scott~\cite{Sewell:2010} and Lambek~\cite{Lambek:1988}.  Our
categorical model leads to a new and simple type theory that combines
dynamic and static typing with explicit casts called Core Grady.  In
addition, it gives a rigorous framework that can be used while
developing new gradual type systems or extensions of existing gradual
type systems.

In addition, to show that Core Grady can be used as the core casting
calculus of gradual type systems we develop a gradually typed surface
language called Surface Grady that translates to Core Grady using a
cast insertion algorithm.  We then show that the gradual guarantee
holds for Surface and Core Grady.

\subsection{Overview}
\label{subsec:main_ideas}
We now give a brief overview of our main results, but from a typed
$\lambda$-calculus perspective, but we will transition to category
theory in Section~\ref{subsec:the_categorical_model}.  Suppose we add
the unknown type, $[[?]]$, and two functions $[[squash]] : [[(? -> ?)
    -> ?]]$ and $[[split]] : [[? -> (? -> ?)]]$ to the simply typed
$\lambda$-calculus with the natural numbers.  Furthermore, we require
that for any program, $[[t]]$, of type $[[? -> ?]]$, we have $[[split
    (squash t)]] \rightsquigarrow t$.  Categorically $[[split]]$ and
$[[squash]]$ define was is called a retract.  Scott \cite{Scott:1980}
showed that this is enough to encode the untyped $\lambda$-calculus
into a statically typed setting:
\begin{center}
  \begin{math} \small
    \begin{array}{lll}
      \setlength{\arraycolsep}{2px}
      \begin{array}{rll}
      [[|x|]]     & = & [[x]]\\
      [[|\x.t|]]  & = & [[\x:?.|t|]]\\      
    \end{array}
      &
      \setlength{\arraycolsep}{2px}
    \begin{array}{rll}
      [[|x t2|]] & = & [[(split x) |t2|]]\\
      [[|t1 t2|]] & = & [[|t1| (squash |t2|)]]
    \end{array}
    \end{array}
  \end{math}
\end{center}
For example, if $\Omega = \lambda x.x\,x$, then $|\Omega| = [[\x:?.H((split x) x)]]$, and
$|\Omega\,\Omega| = |\Omega|\,(\mathsf{squash}\,|\Omega|)$ is the typical diverging term.

We have at this point a typed functional programming language with two
fragments: the statically typed $\lambda$-calculus and the untyped
$\lambda$-calculus.  However, they are just sitting side-by-side.  Now
suppose for any atomic type $[[A]]$, excluding the unknown type, we
add two new functions $[[box A]] : [[A -> ?]]$ and $[[unbox A]] : [[?
    -> A]]$ such that for any term, $[[t]]$, of atomic type $[[A]]$,
we have that $[[unbox A (box A t)]] \rightsquigarrow [[t]]$ -- a
second retract.  This defines the bridge between the typed fragment
and the untyped fragment.  We will show in the next section that both
$[[box]]$ and $[[unbox]]$ can be generalized to arbitrary types, and
thus, they will subsume $[[split]]$ and $[[squash]]$ as well, hence,
reducing all explicit casts to just two functions simplifying the
language even further.

At this point we have basically built up Core Grady
(Section~\ref{sec:core_grady}).  We can move statically type data in
between the two fragments.  For example, we will show in
Section~\ref{sec:core_grady} that using $\Omega$ we can define the Y
combinator, and then use it to define a typed fixpoint operator for
natural numbers which can then be used to define a library of
arithmetic operations.  This example requires data to be to the
untyped world, but then moved back again.

The terms $[[split]]$, $[[squash]]$, $[[box]]$ ,and $[[unbox]]$ all
correspond to explicit casts.  In Section~\ref{sec:surface_grady} we
develop a gradually typed surface language called Surface Grady that
allows for the casts to be left implicit.  Then we show that both
Surface and Core grady can be soundly interpreted into our categorical
model in Section~\ref{sec:interpreting_surface_grady_in_the_model}.

% subsection main_ideas (end)

%%% Local Variables: ***
%%% mode:latex ***
%%% TeX-master: "main.tex"  ***
%%% End: ***
