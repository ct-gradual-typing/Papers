%% Submission instructions:
%%
%% 20 pages max, not including references.
\documentclass{llncs}

\usepackage{graphicx}

\usepackage{amssymb,amsmath}
\usepackage{hyperref}
\usepackage{mathpartir}
\usepackage[barr]{xy}
\usepackage{mdframed}
\usepackage{supertabular}
\usepackage{todonotes}
\usepackage{enumitem}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}

%% From: https://hal.inria.fr/file/index/docid/881085/filename/lsthaskell.sty
\lstdefinelanguage{Haskell}{ 
  %
  % Anything betweeen $ becomes LaTeX math mode
  mathescape=true,
  %
  % Comments may or not include Latex commands
  texcl=false, 
  %
  morekeywords=[1]{omega, fix, ycomb, foldr, foldl, length, zipWith, append},
  %
  morekeywords=[2]{unbox, box, split, squash},
  %
  morekeywords=[3]{r},
  %
  morekeywords=[4]{case, of},
  %
  morekeywords=[6]{do, last, first, try, idtac, repeat},
  %
  % Comments delimiters, we do turn this off for the manual
  morecomment=[s]{(*}{*)},
  %
  % Spaces are not displayed as a special character
  showstringspaces=false,
  %
  % String delimiters
  morestring=[b]",
  morestring=[d]Â’,
  %
  % Size of tabulations
  tabsize=3,
  %
  % Enables ASCII chars 128 to 255
  extendedchars=false,
  %
  % Case sensitivity
  sensitive=true,
  %
  % Automatic breaking of long lines
  breaklines=false,
  %
  % Default style fors listings
  basicstyle=\footnotesize,
  %
  % Position of captions is bottom
  captionpos=b,
  %
  % flexible columns
  columns=[l]flexible,
  %
  % Style for (listings') identifiers
  identifierstyle={\ttfamily\color{black}},
  % Style for declaration keywords
  keywordstyle=[1]{\ttfamily\color{blue}},
  % Style for gallina keywords
  keywordstyle=[2]{\ttfamily\color{dkgreen}},
  % Style for sorts keywords
  keywordstyle=[3]{\ttfamily\color{purple}},
  % Style for tactics keywords
  keywordstyle=[4]{\ttfamily\color{violet}},
  % Style for terminators keywords
  keywordstyle=[5]{\ttfamily\color{dkred}},
  %Style for iterators
  %keywordstyle=[6]{\ttfamily\color{dkpink}},
  % Style for strings
  stringstyle=\ttfamily,
  % Style for comments
  commentstyle={\ttfamily\color{dkgreen}},
  %
  %moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
  literate=
  {->}{{$\rightarrow\;$}}1
  {=>}{{$\Rightarrow\;$}}1
  {<:}{{$<\hspace{-2px}\colon$}}1
  {++}{{\code{++}}}1
  {\{}{{$\langle$}}1
  {\}}{{$\rangle\;$}}1
  {~}{{\ }}1
  {::}{{\text{::}}}1
  {\\dollar}{{$\$$\;}}1
  %
}[keywords,comments,strings]

\lstnewenvironment{haskell}{\lstset{language=Haskell}}{}

\def\ginline{\lstinline[language=Haskell, basicstyle=\small]}

\newenvironment{enumR}{\begin{enumerate}[label=\roman*.,align=left]}{\end{enumerate}}
\newenvironment{enumA}{\begin{enumerate}[label=\alph*.]}{\end{enumerate}}

\newcommand{\cL}{{\cal L}}

\let\mto\to                     % Used for arrows
\let\to\relax                   % Used for implication
\newcommand{\to}{\rightarrow}
\newcommand{\id}{\mathsf{id}}
\newcommand{\redto}{\rightsquigarrow}
\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\catop}[1]{\mathcal{#1}^{\mathsf{op}}}
\newcommand{\Case}[0]{\mathsf{case}}

\let\split\relax
\let\S\relax

\newcommand{\split}[0]{\mathsf{split}}
\newcommand{\squash}[0]{\mathsf{squash}}
\newcommand{\bx}[0]{\mathsf{box}}
\newcommand{\unbox}[0]{\mathsf{unbox}}
\newcommand{\T}[0]{\mathsf{T}}
\newcommand{\S}[0]{\mathsf{S}}
\newcommand{\U}[0]{\mathsf{U}}
\newcommand{\C}[0]{\mathsf{C}}
\newcommand{\z}[0]{\mathsf{z}}
\newcommand{\app}[0]{\mathsf{app}}
\newcommand{\curry}[1]{\mathsf{curry}(#1)}
\newcommand{\interp}[1]{[\negthinspace[#1]\negthinspace]}
\newcommand{\Hom}[3]{\mathsf{Hom}_{\cat{#1}}(#2,#3)}

%% \newtheorem{theorem}{Theorem}
%% \newtheorem{lemma}[theorem]{Lemma}
%% \newtheorem{corollary}[theorem]{Corollary}
%% \newtheorem{definition}[theorem]{Definition}
%% \newtheorem{proposition}[theorem]{Proposition}
%% \newtheorem{example}[theorem]{Example}

%% Ott includes:
\input{surface-grady-inc}
\renewcommand{\SGradydrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\,\SGradydrulename{#4}}}
\renewcommand{\SGradydrulename}[1]{#1}

\renewcommand{\SGradydruleSXXReflName}{\text{refl}}
\renewcommand{\SGradydruleSXXVarName}{\text{var}}
\renewcommand{\SGradydruleSXXBoxName}{\mathsf{box}}
\renewcommand{\SGradydruleSXXUnboxName}{\mathsf{unbox}}
\renewcommand{\SGradydruleSXXListName}{\mathsf{List}}
\renewcommand{\SGradydruleSXXProdName}{\times}
\renewcommand{\SGradydruleSXXArrowName}{\to}
\renewcommand{\SGradydruleSXXForallName}{\forall}
\renewcommand{\SGradydruleSXXTopName}{\text{top}}
\renewcommand{\SGradydruleSXXNatSLName}{\mathsf{Nat}_\mathcal{S}}
\renewcommand{\SGradydruleSXXUnitSLName}{\mathsf{Unit}_\mathcal{S}}
\renewcommand{\SGradydruleSXXListSLName}{\mathsf{List}_\mathcal{S}}
\renewcommand{\SGradydruleSXXArrowSLName}{\to_\mathcal{S}}
\renewcommand{\SGradydruleSXXProdSLName}{\times_\mathcal{S}}

\renewcommand{\SGradydruleCXXReflName}{\text{refl}}
\renewcommand{\SGradydruleCXXBoxName}{\mathsf{box}}
\renewcommand{\SGradydruleCXXUnboxName}{\mathsf{unbox}}
\renewcommand{\SGradydruleCXXListName}{\mathsf{List}}
\renewcommand{\SGradydruleCXXArrowName}{\to}
\renewcommand{\SGradydruleCXXProdName}{\times}
\renewcommand{\SGradydruleCXXForallName}{\forall}

\renewcommand{\SGradydruleTXXvarPName}{\text{var}}
\renewcommand{\SGradydruleTXXBoxName}{\mathsf{box}}
\renewcommand{\SGradydruleTXXUnboxName}{\mathsf{unbox}}
\renewcommand{\SGradydruleTXXunitPName}{\mathsf{Unit}}
\renewcommand{\SGradydruleTXXzeroPName}{\mathsf{zero}}
\renewcommand{\SGradydruleTXXsuccName}{\mathsf{succ}}
\renewcommand{\SGradydruleTXXncaseName}{\mathsf{Nat}_e}
\renewcommand{\SGradydruleTXXemptyName}{\text{empty}}
\renewcommand{\SGradydruleTXXconsName}{\mathsf{List}_i}
\renewcommand{\SGradydruleTXXlcaseName}{\mathsf{List}_e}
\renewcommand{\SGradydruleTXXpairName}{\times_i}
\renewcommand{\SGradydruleTXXfstName}{\times_{e_1}}
\renewcommand{\SGradydruleTXXsndName}{\times_{e_2}}
\renewcommand{\SGradydruleTXXlamName}{\to_i}
\renewcommand{\SGradydruleTXXappName}{\to_e}
\renewcommand{\SGradydruleTXXLamName}{\forall_i}
\renewcommand{\SGradydruleTXXtypeAppName}{\forall_e}
\renewcommand{\SGradydruleTXXSubName}{\text{sub}}

\renewcommand{\SGradydruleciXXvarName}{}
\renewcommand{\SGradydruleciXXBoxName}{}
\renewcommand{\SGradydruleciXXUnboxName}{}
\renewcommand{\SGradydruleciXXzeroName}{}
\renewcommand{\SGradydruleciXXtrivName}{}
\renewcommand{\SGradydruleciXXsuccUName}{}
\renewcommand{\SGradydruleciXXsuccName}{}
\renewcommand{\SGradydruleciXXncaseUName}{}
\renewcommand{\SGradydruleciXXncaseName}{}
\renewcommand{\SGradydruleciXXpairName}{}
\renewcommand{\SGradydruleciXXfstUName}{}
\renewcommand{\SGradydruleciXXfstName}{}
\renewcommand{\SGradydruleciXXsndUName}{}
\renewcommand{\SGradydruleciXXsndName}{}
\renewcommand{\SGradydruleciXXEmptyName}{}
\renewcommand{\SGradydruleciXXconsName}{}
\renewcommand{\SGradydruleciXXlcaseUName}{}
\renewcommand{\SGradydruleciXXlcaseName}{}
\renewcommand{\SGradydruleciXXlamName}{}
\renewcommand{\SGradydruleciXXappUName}{}
\renewcommand{\SGradydruleciXXappName}{}
\renewcommand{\SGradydruleciXXLamName}{}
\renewcommand{\SGradydruleciXXtypeAppName}{}

\input{core-grady-inc}
\renewcommand{\CGradydruleSXXReflName}{\text{refl}}
\renewcommand{\CGradydruleSXXTopName}{\text{top}}
\renewcommand{\CGradydruleSXXVarName}{\text{var}}
\renewcommand{\CGradydruleSXXNatSLName}{\mathsf{Nat}_{\mathcal{S}}}
\renewcommand{\CGradydruleSXXUnitSLName}{\mathsf{Unit}_{\mathcal{S}}}
\renewcommand{\CGradydruleSXXListSLName}{\mathsf{List}_{\mathcal{S}}}
\renewcommand{\CGradydruleSXXArrowSLName}{\to_{\mathcal{S}}}
\renewcommand{\CGradydruleSXXProdSLName}{\times_{\mathcal{S}}}
\renewcommand{\CGradydruleSXXListName}{\mathsf{List}}
\renewcommand{\CGradydruleSXXProdName}{\times}
\renewcommand{\CGradydruleSXXArrowName}{\to}
\renewcommand{\CGradydruleSXXForallName}{\forall}

\renewcommand{\CGradydrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\,\CGradydrulename{#4}}}
\renewcommand{\CGradydrulename}[1]{#1}
\renewcommand{\CGradydruleTXXvarPName}{\text{var}}
\renewcommand{\CGradydruleTXXBoxName}{\mathsf{box}}
\renewcommand{\CGradydruleTXXUnboxName}{\mathsf{unbox}}
\renewcommand{\CGradydruleTXXsquashName}{\mathsf{squash}}
\renewcommand{\CGradydruleTXXsplitName}{\mathsf{split}}
\renewcommand{\CGradydruleTXXunitPName}{\mathsf{Unit}}
\renewcommand{\CGradydruleTXXzeroPName}{\text{zero}}
\renewcommand{\CGradydruleTXXsuccName}{\mathsf{succ}}
\renewcommand{\CGradydruleTXXncaseName}{\mathsf{Nat}_e}
\renewcommand{\CGradydruleTXXemptyName}{\text{empty}}
\renewcommand{\CGradydruleTXXconsName}{\mathsf{List}_i}
\renewcommand{\CGradydruleTXXlcaseName}{\mathsf{List}_e}
\renewcommand{\CGradydruleTXXpairName}{\times_i}
\renewcommand{\CGradydruleTXXfstName}{\times_{e_1}}
\renewcommand{\CGradydruleTXXsndName}{\times_{e_2}}
\renewcommand{\CGradydruleTXXlamName}{\to_i}
\renewcommand{\CGradydruleTXXappName}{\to_e}
\renewcommand{\CGradydruleTXXLamName}{\forall_i}
\renewcommand{\CGradydruleTXXtypeAppName}{\forall_e}
\renewcommand{\CGradydruleTXXSubName}{\text{sub}}
\renewcommand{\CGradydruleTXXerrorName}{\text{error}}

\renewcommand{\CGradydrulerdXXretracTName}{\text{retract}_1}
\renewcommand{\CGradydrulerdXXretracTEName}{\text{error}_1}
\renewcommand{\CGradydrulerdXXretractUName}{\text{retract}_2}
\renewcommand{\CGradydrulerdXXretractUEName}{\text{error}_2}
\renewcommand{\CGradydrulerdXXncaseZeroName}{\mathsf{Nat}_{e_1}}
\renewcommand{\CGradydrulerdXXncaseSuccName}{\mathsf{Nat}_{e_2}}
\renewcommand{\CGradydrulerdXXncaseName}{}
\renewcommand{\CGradydrulerdXXlcaseEmptyName}{\mathsf{List}_{e_1}}
\renewcommand{\CGradydrulerdXXlcaseConsName}{\mathsf{List}_{e_2}}
\renewcommand{\CGradydrulerdXXheadName}{}
\renewcommand{\CGradydrulerdXXtailName}{}
\renewcommand{\CGradydrulerdXXlcaseName}{}
\renewcommand{\CGradydrulerdXXbetaName}{\beta}
\renewcommand{\CGradydrulerdXXprojOneName}{\times_{e_1}}
\renewcommand{\CGradydrulerdXXprojTwoName}{\times_{e_2}}
\renewcommand{\CGradydrulerdXXappName}{}
\renewcommand{\CGradydrulerdXXsplitName}{}
\renewcommand{\CGradydrulerdXXunboxName}{}
\renewcommand{\CGradydrulerdXXfstName}{}
\renewcommand{\CGradydrulerdXXsndName}{}
\renewcommand{\CGradydrulerdXXpairOneName}{}
\renewcommand{\CGradydrulerdXXpairTwoName}{}
\renewcommand{\CGradydrulerdXXtypeBetaName}{\text{type}_{\beta}}
\renewcommand{\CGradydrulerdXXtypeAppName}{}

\def\lastname{Eades III and Townsend}

\begin{document}

\title{Bounded Quantification for Gradual Typing}
\titlerunning{Bounded Quantification for Gradual Typing}

\author{Harley Eades III \and Michael Townsend}
\authorrunning{Eades III \and Townsend}
\institute{Computer and Information Sciences \\ Augusta University \\ Augusta, USA \\ \email{heades@augusta.edu}}

\maketitle

\begin{abstract} 
  In an earlier paper we introduce a new categorical model based on
  retracts that combines static and dynamic typing.  We then showed
  that our model gave rise to a new and simple type system which
  combines static and dynamic typing.  In this paper, we extend this
  type system with bounded quantification and lists, and then develop
  a gradually typed surface language that uses our new type system as
  a core casting calculus.  Finally, we prove the gradual guarantee as
  put forth by Siek et al.
\end{abstract}

\section{Introduction}
\label{sec:introduction}
\input{introduction-ott}
% section introduction (end)

\section{Related Work}
\label{sec:related-work}
\input{related-work-ott}
% section related-work (end)

\section{Grady: A Categorically Inspired Gradual Type System}
\label{sec:grady:_a_categorical_inspired_gradual_type_system}

We begin by introducing the surface and core languages making up
Grady.  Throughout this section we give a number of interesting
examples.  All example programs will be given in the concrete syntax
of Grady\footnote{The implementation and documentation of Grady can be
  found at \url{http://www.ct-gradual-typing.github.io/Grady}.}.  Both
the surface and the core languages are based on Bounded System F; for
an introduction please see Pierce~\cite{Pierce:2002:TPL:509043}.

\subsection{Surface Grady: A Gradual Type System}
\label{subsec:surface_grady:_a_gradual_type_system}
\input{surface-grady-ott}
% subsection surface_grady:_a_gradual_type_system (end)

\subsection{Core Grady: The Casting Calculus}
\label{subsec:core_grady:_the_casting_calculus}
\input{core-grady-ott}
% subsection core_grady:_the_casting_calculus (end)

\section{Analyzing Grady}
\label{sec:results}
\input{results-ott}
% subsection results (end)

% section grady:_a_categorically_inspired_gradual_type_system (end)

\bibliographystyle{splncs}
\bibliography{references}

\appendix

\input{proofs-ott}

% section proofs (end)
\end{document}
