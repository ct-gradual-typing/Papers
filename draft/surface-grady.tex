\renewcommand{\SGradydruleSXXReflName}{\text{refl}}
\renewcommand{\SGradydruleSXXTransName}{\text{trans}}
\renewcommand{\SGradydruleSXXVarName}{\text{var}}
\renewcommand{\SGradydruleSXXTopName}{\top}
\renewcommand{\SGradydruleSXXNatSName}{[[Nat]]_{[[SL]]}}
\renewcommand{\SGradydruleSXXUnitSName}{[[Unit]]_{[[SL]]}}
\renewcommand{\SGradydruleSXXListSName}{\mathsf{List}_{[[SL]]}}
\renewcommand{\SGradydruleSXXArrowSName}{\to_{[[SL]]}}
\renewcommand{\SGradydruleSXXProdSName}{\times_{[[SL]]}}
\renewcommand{\SGradydruleSXXListName}{\mathsf{List}}
\renewcommand{\SGradydruleSXXProdName}{\times}
\renewcommand{\SGradydruleSXXArrowName}{\to}
\renewcommand{\SGradydruleSXXForallName}{\forall}
\begin{figure}
  \begin{mdframed}
    \begin{mathpar}
    \SGradydruleSXXRefl{} \and
    \SGradydruleSXXTrans{} \and
    \SGradydruleSXXVar{} \and
    \SGradydruleSXXTop{} \and
    \SGradydruleSXXNatS{} \and
    \SGradydruleSXXUnitS{} \and
    \SGradydruleSXXListS{} \and
    \SGradydruleSXXArrowS{} \and
    \SGradydruleSXXProdS{} \and
    \SGradydruleSXXList{} \and
    \SGradydruleSXXProd{} \and
    \SGradydruleSXXArrow{} \and
    \SGradydruleSXXForall{}
  \end{mathpar}
  \end{mdframed}
  \caption{Subtyping for Surface Grady}
  \label{fig:subtyping-surface-grady}
\end{figure}

\renewcommand{\SGradydruleCXXReflName}{\text{refl}}
\renewcommand{\SGradydruleCXXBoxName}{[[box]]}
\renewcommand{\SGradydruleCXXUnboxName}{[[unbox]]}
\renewcommand{\SGradydruleCXXListName}{\mathsf{List}}
\renewcommand{\SGradydruleCXXArrowName}{\to}
\renewcommand{\SGradydruleCXXProdName}{\times}
\renewcommand{\SGradydruleCXXForallName}{\forall}
\begin{figure}
  \begin{mdframed}
    \begin{mathpar}
      \SGradydruleCXXRefl{} \and
      \SGradydruleCXXBox{} \and
      \SGradydruleCXXUnbox{} \and
      \SGradydruleCXXList{} \and
      \SGradydruleCXXArrow{} \and
      \SGradydruleCXXProd{} \and
      \SGradydruleCXXForall{}      
    \end{mathpar}
  \end{mdframed}  
  \caption{Type consistency for Surface Grady}
  \label{fig:type-consistency-surface-grady}
\end{figure}

\renewcommand{\SGradydruleTXXvarPName}{\text{var}}
\renewcommand{\SGradydruleTXXBoxName}{[[box]]}
\renewcommand{\SGradydruleTXXUnboxName}{[[unbox]]}
\renewcommand{\SGradydruleTXXunitPName}{[[Unit]]}
\renewcommand{\SGradydruleTXXzeroPName}{\mathsf{zero}}
\renewcommand{\SGradydruleTXXsuccName}{[[succ]]}
\renewcommand{\SGradydruleTXXncaseName}{[[Nat]]_e}
\renewcommand{\SGradydruleTXXemptyName}{\text{empty}}
\renewcommand{\SGradydruleTXXconsName}{\mathsf{List}_i}
\renewcommand{\SGradydruleTXXlcaseName}{\mathsf{List}_e}
\renewcommand{\SGradydruleTXXpairName}{\times_i}
\renewcommand{\SGradydruleTXXfstName}{\times_{e_1}}
\renewcommand{\SGradydruleTXXsndName}{\times_{e_2}}
\renewcommand{\SGradydruleTXXlamName}{\to_i}
\renewcommand{\SGradydruleTXXappName}{\to_e}
\renewcommand{\SGradydruleTXXLamName}{\forall_i}
\renewcommand{\SGradydruleTXXtypeAppName}{\forall_e}
\renewcommand{\SGradydruleTXXSubName}{\text{sub}}
\begin{figure}
  \begin{mdframed}
    \begin{mathpar}
      \SGradydruleTXXvarP{} \and
      \SGradydruleTXXBox{} \and
      \SGradydruleTXXUnbox{} \and
      \SGradydruleTXXunitP{} \and
      \SGradydruleTXXzeroP{} \and
      \SGradydruleTXXsucc{} \and
      \SGradydruleTXXncase{} \and
      \SGradydruleTXXempty{} \and
      \SGradydruleTXXcons{} \and
      \SGradydruleTXXlcase{} \and      
      \SGradydruleTXXpair{} \and
      \SGradydruleTXXfst{} \and
      \SGradydruleTXXsnd{} \and      
      \SGradydruleTXXlam{} \and
      \SGradydruleTXXapp{} \and      
      \SGradydruleTXXLam{} \and
      \SGradydruleTXXtypeApp{} \and
      \SGradydruleTXXSub{}
    \end{mathpar}
  \end{mdframed}
  \caption{Typing rules for Surface Grady}
  \label{fig:typing-surface-grady}
\end{figure}

\renewcommand{\SGradydruleciXXvarName}{}
\renewcommand{\SGradydruleciXXBoxName}{}
\renewcommand{\SGradydruleciXXUnboxName}{}
\renewcommand{\SGradydruleciXXzeroName}{}
\renewcommand{\SGradydruleciXXtrivName}{}
\renewcommand{\SGradydruleciXXsuccUName}{}
\renewcommand{\SGradydruleciXXsuccName}{}
\renewcommand{\SGradydruleciXXncaseUName}{}
\renewcommand{\SGradydruleciXXncaseName}{}
\renewcommand{\SGradydruleciXXpairName}{}
\renewcommand{\SGradydruleciXXfstUName}{}
\renewcommand{\SGradydruleciXXfstName}{}
\renewcommand{\SGradydruleciXXsndUName}{}
\renewcommand{\SGradydruleciXXsndName}{}
\renewcommand{\SGradydruleciXXEmptyName}{}
\renewcommand{\SGradydruleciXXconsName}{}
\renewcommand{\SGradydruleciXXlcaseUName}{}
\renewcommand{\SGradydruleciXXlcaseName}{}
\renewcommand{\SGradydruleciXXlamName}{}
\renewcommand{\SGradydruleciXXappUName}{}
\renewcommand{\SGradydruleciXXappName}{}
\renewcommand{\SGradydruleciXXLamName}{}
\renewcommand{\SGradydruleciXXtypeAppName}{}
\begin{figure}
  \begin{mdframed}
    \begin{mathpar}
      \SGradydruleciXXvar{} \and
      \SGradydruleciXXBox{} \and
      \SGradydruleciXXUnbox{} \and
      \SGradydruleciXXzero{} \and
      \SGradydruleciXXtriv{} \and
      \SGradydruleciXXsuccU{} \and
      \SGradydruleciXXsucc{} \and
      \SGradydruleciXXncaseU{} \and
      \SGradydruleciXXncase{} \and
      \SGradydruleciXXpair{} \and
      \SGradydruleciXXfstU{} \and
      \SGradydruleciXXfst{} \and
      \SGradydruleciXXsndU{} \and
      \SGradydruleciXXsnd{} \and
      \SGradydruleciXXEmpty{} \and
      \SGradydruleciXXcons{} \and
      \SGradydruleciXXlcaseU{} \and
      \SGradydruleciXXlcase{} \and
      \SGradydruleciXXlam{} \and
      \SGradydruleciXXappU{} \and
      \SGradydruleciXXapp{} \and
      \SGradydruleciXXLam{} \and
      \SGradydruleciXXtypeApp{}
    \end{mathpar}
  \end{mdframed}
  \caption{Cast insertion for Surface Grady}
  \label{fig:cast-insert-surface-grady}
\end{figure}

\begin{lemma}[Inclusion of Bounded System F]
  \label{lemma:F-inclusion}
  Suppose $t$ is fully annotated and does not contain any applications
  of $[[box]]$ or $[[unbox]]$, and $[[A]]$ is static.  Then
  \begin{itemize}
  \item[]
  \item[i.] $[[G |-F t : A]]$ if and only if $\,[[G |- t : A]]$.
  \item[ii.] $[[t F~>* t']]$ if and only if $[[t ~>* t']]$.
  \end{itemize}
\end{lemma}
\begin{proof}
  We give proof sketches for both parts.  The interesting cases are
  the right-to-left directions of each part.  If we simply remove all
  rules mentioning the unknown type $[[?]]$ and the type consistency
  relation, and then remove $[[box]]$, $[[unbox]]$, and $[[?]]$ from
  the syntax of Surface Grady, then what we are left with is bounded
  system F.  Since $[[t]]$ is fully annotated and $[[A]]$ is static,
  then $[[G |- t : A]]$ will hold within this fragment.

  Moving on to part two, first, we know that $[[t]]$ does not contain
  any occurrence of $[[box]]$ or $[[unbox]]$ and is fully annotated.
  This implies that $[[t]]$ lives within the bounded system F fragment
  of Surface Grady. Thus, before evaluation of $[[t]]$ Surface Grady
  will apply the cast insertion algorithm which will at most insert
  applications of the identity function into $[[t]]$ producing a term
  $\widehat{[[t]]}$, but then after potentially more than one step of
  evaluation within Core Grady, those applications of the identity
  function will be $\beta$-reduced away resulting in $\widehat{[[t]]}
  \rightsquigarrow^* [[t]] \rightsquigarrow^* [[t']]$.  In addition,
  since $[[t]]$ in Surface Grady is the exact same program as $[[t]]$
  in bounded system F, then we know $[[t F~>* t']]$ will hold.
\end{proof}
