\input{aux-results-proofs-ott}

\section{Proofs}
\label{sec:proofs}

\subsection{Proof of Lifted Retract (Lemma~\ref{lemma:lifted_retract})}
\label{subsec:proof_of_lifted_retract}
This is a proof by induction on the form of $[[A]]$.

\begin{itemize}
\item[] Case. Suppose $[[A]]$ is atomic.  Then:
  \[
    [[lbox A]];[[lunbox A]] = [[box A]];[[unbox A]] = \id_{[[A]]}
    \]
    
  \item[] Case. Suppose $[[A]]$ is $[[?]]$.  Then:
    \[
    \begin{array}{lll}
      [[lbox A]];[[lunbox A]] & = & [[lbox ?]];[[lunbox ?]]\\
      & = & \id_{[[?]]};\id_{[[?]]}\\
      & = & \id_{[[?]]}\\
      & = & \id_{[[A]]}
    \end{array}
    \]

  \item[] Case. Suppose $[[A]] = [[A1 -> A2]]$.  Then:
    \[\small
    \begin{array}{lll}
      [[lbox A]];[[lunbox A]]
      & = & [[lbox (A1 -> A2)]];[[lunbox (A1 -> A2)]]\\
      & = & ([[lunbox A1]] \to [[lbox A2]]);([[lbox A1]] \to [[lbox A2]])\\
      & = & ([[lbox A1]];[[lunbox A1]]) \to ([[lbox A2]];[[lunbox A2]])\\
    \end{array}
    \]
    By two applications of the induction hypothesis we know the
    following:
    \[
    \begin{array}{lll}
      [[lbox A1]];[[lunbox A1]] = \id_{[[A1]]} & \text{ and } & [[lbox A2]];[[lunbox A2]] = \id_{[[A2]]}
    \end{array}
    \]
    Thus, we know the following:
    \[
    \begin{array}{lll}
      ([[lbox A1]];[[lunbox A1]]) \to ([[lbox A2]];[[lunbox A2]])
      & = & \id_{[[A1]]} \to \id_{[[A2]]}\\
      & = & \id_{[[A1 -> A2]]}\\
      & = & \id_{[[A]]}
    \end{array}
    \]

  \item[] Case. Suppose $[[A]] = [[A1 x A2]]$.  Then:
    \[\small
    \begin{array}{lll}
      [[lbox A]];[[lunbox A]]
      & = & [[lbox (A1 x A2)]];[[lunbox (A1 x A2)]]\\
      & = & ([[lbox A1]] \times [[lbox A2]]);([[lunbox A1]] \times [[lbox A2]])\\
      & = & ([[lbox A1]];[[lunbox A1]]) \times ([[lbox A2]];[[lunbox A2]])\\
    \end{array}
    \]
    By two applications of the induction hypothesis we know the
    following:
    \[
    \begin{array}{lll}
      [[lbox A1]];[[lunbox A1]] = \id_{[[A1]]} & \text{ and } & [[lbox A2]];[[lunbox A2]] = \id_{[[A2]]}
    \end{array}
    \]
    Thus, we know the following:
    \[
    \begin{array}{lll}
      ([[lbox A1]];[[lunbox A1]]) \times ([[lbox A2]];[[lunbox A2]])
      & = & \id_{[[A1]]} \times \id_{[[A2]]}\\
      & = & \id_{[[A1 x A2]]}\\
      & = & \id_{[[A]]}
    \end{array}
    \]
\end{itemize}
% subsection proof_of_lifted_retract (end)

\subsection{Proof of Lemma~\ref{lemma:S_is_faithful}}
\label{subsec:proof_of_S_is_faithful}
We must show that the function
\[ \S_{A,B} : \Hom{C}{A}{B} \mto \Hom{S}{\S A}{\S B} \]
is injective.

So suppose $f \in \Hom{C}{A}{B}$ and $g \in \Hom{C}{A}{B}$ such that
$\S f = \S g : \S A \mto \S B$.  Then we can easily see that:
\[
\begin{array}{lll}
  \S f & = & [[lunbox A]];f;[[lbox B]] \\
  & = & [[lunbox A]];g;[[lbox B]]\\
  & = & \S g\\
\end{array}
\]
But, we have the following equalities:
\[
\begin{array}{rll}
  [[lunbox A]];f;[[lbox B]] & = & [[lunbox A]];g;[[lbox B]]\\
  [[lbox A]];[[lunbox A]];f;[[lbox B]];[[lunbox B]] & = & [[lbox A]];[[lunbox A]];g;[[lbox B]];[[lunbox B]]\\
  \id_A;f;[[lbox B]];[[lunbox B]] & = & \id_A;g;[[lbox B]];[[lunbox B]]\\
  \id_A;f;\id_B & = & \id_A;g;\id_B\\
  f & = & g\\
\end{array}
\]
The previous equalities hold due to
Lemma~\ref{lemma:lifted_retract}.
% subsection proof_of_S_is_faithful (end)

\subsection{Proof of Type Consistency in the Model (Lemma~\ref{lemma:type_consistency_in_the_model})}
\label{subsec:proof_of_type_consistency_in_the_model}
This is a proof by induction on the form of $[[A ~ B]]$.
\begin{itemize}
\item[] Case.
  \[
  \GSiekdrulerefl{}
  \]
  Choose $c_1 = c_2 = \id_A : [[A --> A]]$.

\item[] Case.
  \[
  \GSiekdrulebox{}
  \]
  Choose $c_1 = [[Box A]] : [[A --> ?]]$ and $c_2 = [[Unbox A]] : [[? -> A]]$.

\item[] Case.
  \[
  \GSiekdruleunbox{}
  \]
  Choose $c_1 = [[Unbox A]] : [[? --> A]]$ and $c_2 = [[Box A]] : [[A -> ?]]$.
  
\item[] Case.
  \[
  \GSiekdrulearrow{}
  \]
  By the induction hypothesis there exists four casting morphisms
  $c'_1 : [[A1 --> A2]]$, $c'_2 : [[A2 --> A1]]$, $c'_3 : [[B1 --> B2]]$,
  and $c'_4 : [[B2 --> B1]]$.  Choose
  $c_1 = c'_2 \to c'_3 : [[(A1 -> B1) --> (A2 -> B2)]]$
  and
  $c_2 = c'_1 \to c'_4 : [[(A2 -> B2) --> (A1 -> B1)]]$.

\item[] Case.
  \[
  \GSiekdruleprod{}
  \]
  By the induction hypothesis there exists four casting morphisms
  $c'_1 : [[A1 --> A2]]$, $c'_2 : [[A2 --> A1]]$, $c'_3 : [[B1 --> B2]]$,
  and $c'_4 : [[B2 --> B1]]$.
  Choose
  $c_1 = c'_1 \times c'_3 : [[H(A1 x B1) --> H(A2 x B2)]]$
  and
  $c_2 = c'_2 \times c'_4 : [[H(A2 x B2) --> H(A1 x B1)]]$.
\end{itemize}
% subsection proof_of_type_consistency_in_the_model (end)

\subsection{Proof of Interpretation of Types Theorem~\ref{thm:interpretation_of_typing}}
\label{subsec:proof_of_interpretation_of_types}
\begin{comment}
  %% This is a proof by induction on $[[G |- t : A]]$.  First, we show how
%% to interpret the rules of $\lambda^?_\to$, and then $\lambda^{\langle [[A]] \rangle}_\to$.

%% \begin{itemize} 
%% \item[] Case.
%%   \[
%%   \SLGradydrulevar{}
%%   \]
%%   Suppose with out loss of generality that $[[ [| G |] ]] = [[A1]]
%%   \times \cdots \times [[Ai]] \times \cdots \times [[Aj]]$ where
%%   $[[Ai]] = [[A]]$.  We know that $j > 0$ or the assumed typing
%%   derivation would not hold.  Then take
%%   $[[ [| x |] ]] = \pi_i : [[ [| G |] --> A]]$.

%% \item[] Case.
%%   \[
%%   \SLGradydruleunit{}
%%   \]

%%   Take $[[ [| triv |] ]] = \diamond_{[[ [| G |] ]]} : [[ [| G |] -->
%%       1]]$ where $\diamond_{[[ [| G |] ]]}$ is the unique terminal
%%   arrow that exists because $\cat{C}$ is cartesian closed.
  
%% \item[] Case.
%%   \[
%%   \SLGradydrulezero{}
%%   \]

%%   Take $[[ [| 0 |] ]] = \diamond_{[[ [| G |] ]]};\z : [[ [| G |] --> Nat]]$
%%   where $\z : [[1 --> Nat]]$ exists because $\cat{C}$
%%   contains a SNNO.

%% \item[] Case.
%%   \[
%%   \SLGradydrulesuccS{}
%%   \]
  
  
%% \item[] Case.
%%   \[
%%   \SLGradydrulepair{}
%%   \]
%%   By two applications of the induction hypothesis there are two morphisms
%%   $[[ [| t1 |] ]] : [[ [| G |] --> A]]$ and $[[ [| t2 |] ]] : [[ [| G |] --> B]]$.
%%   Then using the fact that $\cat{C}$ is cartesian we take
%%   $[[ [| (t1 , t2) |] ]] = \langle [[ [| t1 |] ]] , [[ [| t2 |] ]] \rangle : [[ [| G |] --> H(A x B)]]$.

%% \item[] Case.
%%   \[
%%   \SLGradydrulefstS{}
%%   \]
%%   TODO

%% \item[] Case.
%%   \[
%%   \SLGradydrulesndS{}
%%   \]
%%   TODO

%% \item[] Case.
%%   \[
%%   \SLGradydrulelam{}
%%   \] 
%%   By the induction hypothesis there is a morphism $[[ [| t |] ]] :
%%   [[ H([| G |] x A) --> B]]$.  Then take $[[ [| \x : A.t |] ]] =
%%   \curry {[[ [| t |] ]]} : [[ [| G |] --> (A -> B)]]$, where
%%   $\mathsf{curry} : \Hom{C}{X \times Y}{Z} \mto \Hom{C}{X}{Y \to Z}$
%%   exists because $\cat{C}$ is closed.

%% \item[] Case.
%%   \[
%%   \SLGradydruleappS{}
%%   \]
%%   TODO
  
%% \end{itemize}

%% Next we turn to $\lambda^{\langle [[A]] \rangle }_\to$, but we do
%% not show every rule, because it corresponds to the simply typed
%% $\lambda$-calculus whose interpretation is similar to what we have
%% already shown above except without casting morphism, and so we only
%% show the case for the cast rule.
%% \begin{itemize}
%% \item[] Case.
%%   \[
%%   \SLGradydrulecast{}
%%   \]
%%   By the induction hypothesis there is a morphism $[[ [| t |] ]] : [[ [| G |] --> A]]$,
%%   and by type consistency in the model (Lemma~\ref{lemma:type_consistency_in_the_model})
%%   there is a casting morphism $c_1 : [[A --> B]]$.  So take
%%   $[[ [| < B > t |] ]] = [[ [| t |] ]];c_1 : [[ [| G |] --> B]]$.
%% \end{itemize}

\end{comment}
% subsection proof_of_interpretation_of_types (end)

\subsection{Proof of Interpretation of Evaluation (Theorem~\ref{thm:interpretation_of_evaluation})}
\label{subsec:proof_of_interpretation_of_evaluation}
This proof holds by induction on the form of $[[G |- t1 ~> t2 : A]]$.
We only show the cases for the casting rules, because the others are
well-known to hold within any cartesian closed category; see
\cite{Lambek:1980} or \cite{Crole:1994}.  We will routinely use
Theorem~\ref{thm:interpretation_of_typing} throughout this proof
without mention.

% subsection proof_of_interpretation_of_evaluation (end)

\subsection{Proof of Lemma~\ref{lemma:syntactic_box_and_unbox}}
\label{subsec:proof_of_lemma_syntactic_box_and_unbox}
First, we define the identify meta-function:
  \[
  \id_A := [[\x : A . x]]
  \]
  Then composition.  Suppose $[[G |- t1 : A -> B]]$ and $[[G |- t2 : B -> D]]$
  are two terms, then we define:
  \[
  [[t1 ; t2]] := [[\x : A . H(t2 (t1 x))]]
  \]
  It is easy to see that the following rule is admissible:
  \begin{center}
    \begin{math}
      $$\mprset{flushleft}
      \inferrule* [right=\text{comp}] {
        [[G |- t1 : A -> B]]
        \\
          [[G |- t2 : B -> D]]
      }{[[G |- t1;t2 : A -> D]]}
    \end{math}
  \end{center}
  The functor $- \times -$ requires two morphisms $[[G |- t1 : A -> D]]$ and
  $[[G |- t2 : B -> E]]$, and is defined as follows:
  \[
  [[t1]] \times [[t2]] := [[\ x : A x B.(t1 (fst x), t2 (snd x))]]
  \]
  The following rule is admissible:
  \begin{center}
    \begin{math}
      $$\mprset{flushleft}
      \inferrule* [right=\text{prod}] {
        [[G |- t1 : A -> D]]
        \\
        [[G |- t2 : B -> E]]
      }{[[G |- t1 XX t2 : H(A x B) -> H(D x E)]]}
    \end{math}
  \end{center}
  The functor $- \to -$ requires two morphisms $[[G |- t1 : D -> A]]$ and
  $[[G |- t2 : B -> E]]$, and is defined as follows:
  \[
  [[t1 -> t2]] := [[\ f : A -> B.\y : D.H(t2 (f (t1 y)))]]
  \]
  The following rule is admissible:
  \begin{center}
    \begin{math}
      $$\mprset{flushleft}
      \inferrule* [right=\text{prod}] {
        [[G |- t1 : D -> A]]
        \\
        [[G |- t2 : B -> E]]
      }{[[G |- t1 -> t2 : (A -> B) -> (D -> E)]]}
    \end{math}
  \end{center}
  At this point it is straightforward to carry out the definition of
  $[[Box A]]$ and $[[Unbox A]]$ using the definitions from the model.
  Showing the admissibility of the typing and reduction rules follows
  by induction on $[[A]]$.
  % subsection proof_of_lemma_syntactic_box_and_unbox (end)
% section proofs (end)

\input{proofs-gradual-guarantee-part-one-ott}

%%% Local Variables: ***
%%% mode:latex ***
%%% TeX-master: "main.tex"  ***
%%% End: ***
