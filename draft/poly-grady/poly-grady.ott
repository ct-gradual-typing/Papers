metavar termvar, x, y , z, f ::=
metavar typevar, X, Y , Z ::=
indexvar index, i , j, k ::=

grammar
  t, c, v, s, n :: 't_' ::=                    
    | x                   ::   :: var          
    | triv                ::   :: unit         
    {{tex \mathsf{triv} }}
    | squash S            ::   :: inj          
    {{tex \mathsf{squash}_{[[S]]} }}
    | split S             ::   :: surj         
    {{tex \mathsf{split}_{[[S]]} }}    
    | box                 ::   :: gen          
    {{tex \mathsf{box} }}
    | box A               ::   :: genA
    {{tex \mathsf{box}_{[[A]]} }}        
    | unbox A             ::   :: specA         
    {{tex \mathsf{unbox}_{[[A]]} }}
    | unbox               ::   :: spec
    {{tex \mathsf{unbox} }}    
    | Lam X <: A . t      ::    :: TypeLam
    {{tex \Lambda ([[X]] <\hspace{-2px}\colon [[A]]) .[[t]] }}
    | [ A ] t             ::   :: TypeApp
    {{tex [ [[A]] ] [[t]] }}    
    | \ x : A . t         ::   :: abs          
    {{tex \lambda ([[x]] : [[A]]) . [[t]] }}
    | t1 t2               ::   :: app          
    | ( t1 , t2 )         ::   :: pair         
    | fst t               ::   :: proj1        
    | snd t               ::   :: proj2        
    | succ t              ::   :: successor    
    | 0                   ::   :: zero         
    | ncase t of 0 -> t1 , t' -> t2 :: :: natElim
    {{tex \mathsf{ncase}\,[[t]]\,\mathsf{of}\,0 \to [[t1]], [[t']] \to [[t2]] }}
    | []                  ::   :: emptylist
    | t : : t'            ::   :: cons
    {{tex [[t]] :: [[t']] }}
    | lcase t of [] -> t1 , t' -> t2 :: :: listElim
    {{tex \mathsf{lcase}\,[[t]]\,\mathsf{of}\,[] \to [[t1]], [[t']] \to [[t2]] }}    
    | ( t )               :: S :: parens
    | [ t1 / x ] t2       :: M :: subst
    | H( t )              :: M :: hparens
    {{tex [[t]] }}
    | squash              :: M  :: injU   
    {{tex \mathsf{squash} }}
    | split               :: M :: surjU
    {{tex \mathsf{split} }}    
    | [ A / X ] t         :: M :: TypeSub   

  K :: 'K_' ::=
    | *                   ::   :: TypeOfTypes
    {{tex \star }}

  A, B, C, D, E, S, U :: 'A_' ::=   
    | X                   ::   :: Var
    | List A              ::   :: List
    {{tex \mathsf{List}\,[[A]] }}
    | Forall ( X <: A ) . B   ::   :: Forall
    {{tex \forall ([[X]] <\hspace{-2px}\colon [[A]]). [[B]]}}
    | Top                 ::   :: top
    {{tex \top }}
    | SL                  ::   :: Simple
    {{tex \mathbb{S} }}
    | Unit                ::   :: term    
    {{tex \mathsf{Unit} }}
    | Nat                 ::   :: nat     
    {{tex \mathsf{Nat} }}    
    | ?                   ::   :: unitype 
    | A1 -> A2            ::   :: arrow   
    | A1 x A2             ::   :: pair    
    {{tex [[A1]] \times [[A2]] }}     
    | ( A )               :: S :: paren
    | H( A )              :: M :: hparen
    {{tex [[A]] }}
    | [ A / X ] B         :: M :: TypeSub

  G {{ tex \Gamma }} :: G_ ::=            
    | .                   ::   :: emptyCtx
    {{tex \cdot }}
    | G , X <: A           ::   :: tvn
    {{tex [[G]],[[X]] <\hspace{-2px}\colon [[A]] }}
    | G , x : A           ::   :: vn      
    | G , G'              :: M :: append  
    | ( G )               :: M :: parens

  terminals :: 'terminals_' ::=
    |  ->                 ::   :: arrow
    {{tex \rightarrow }}
    | |-                  ::   :: turnstile
    {{tex \vdash }}
    | |~                  ::   :: ndash
    {{tex \not \vdash }}    
    | succ                ::   :: succ
    {{tex \mathsf{succ} }}
    | ?                   ::   :: unitype
    | ~                   ::   :: cons
    {{tex \sim }}
    | ~U                  ::   :: conv
    {{tex \sim_U }}    
    | elem                ::   :: elem
    {{tex \in }}
    | ~>                  ::   :: red
    {{tex \rightsquigarrow }}
    | box        :: :: box
    {{tex \mathsf{box} }}
    | unbox        :: :: unbox
    {{tex \mathsf{unbox} }}
    | fst        :: :: fst
    {{tex \mathsf{fst} }}
    | snd        :: :: snd
    {{tex \mathsf{snd} }}                

  formula :: 'formula_' ::=
    | judgement           ::   :: judgement
    | x nin FV( t )       ::   :: NinFV
    {{tex [[x]] \not\in \mathsf{FV}([[t]]) }}
    | x : A elem G        ::   :: xTelemG
    | X <: A elem G        ::   :: XTelemG
    {{tex [[X]] <\hspace{-2px}\colon [[A]] \in [[G]] }}
    | formula1 && formula2 ::  :: Quad
    {{tex [[formula1]] \quad [[formula2]] }}
    | ( formula )         :: S :: parens
    {{tex [[formula]] }}    
    | t : A               :: M :: TermHasType
  
defns
  Typing :: '' ::=

defn
   G |- A : * :: :: kind :: 'K_'
   {{tex [[G]] \vdash [[A]] : \star }} by

   G1 |- A : *
   ----------------------- :: var
   G1, X <: A,G2 |- X : *

   ------------- :: unit
   G |- Unit : *

   ------------ :: nat
   G |- Nat : *

   ---------- :: unitype
   G |- ? : *

   G |- A : *
   --------------- :: list
   G |- List A : *

   G |- A : * && G |- B : *
   ------------------------ :: arrow
   G |- A -> B : *

   G |- A : * && G |- B : *
   ------------------------ :: prod
   G |- A x B : *

   G, X <: A |-  B : *
   -------------------------- :: forall
   G |- Forall (X <: A) . B : *

defn
    G Ok :: :: ctxOk :: 'Ok_'
    {{tex [[G]]\,\text{Ok} }} by

   ---- :: empty
   . Ok

   G Ok && G |- A : *
   ------------------ :: typeVar
   (G, X <: A) Ok

   G Ok && G |- A : *
   ------------------ :: var
   (G, x : A) Ok

defn
    G |- A <: B :: :: subtype :: 'S_'
    {{tex [[G]] \vdash [[A]] <\hspace{-2px}\colon [[B]] }} by

    G Ok
    ----------- :: Refl
    G |- A <: A

    G |- A <: B && G |- B <: C
    -------------------------- :: Trans
    G |- A <: C

    G Ok
    -------------- :: Top
    G |- A <: Top

    G Ok
    -------------- :: Nat
    G |- Nat <: SL

    G Ok
    --------------- :: Unit
    G |- Unit <: SL

    G |- A <: SL
    ----------------- :: ListSL
    G |- List A <: SL

    X <: A elem G && G Ok
    ---------------------:: Var
    G |- X <: A

    G |- A <: B
    --------------------- :: List
    G |- List A <: List B

    G |- A <: SL && G |- B <: SL
    ---------------------------- :: ArrowSL
    G |- A -> B <: SL

    G |- A <: SL && G |- B <: SL
    ---------------------------- :: ProdSL
    G |- A x B <: SL

    G |- A1 <: A2 && G |- B1 <: B2
    ------------------------------ :: Prod
    G |- A1 x B1 <: A2 x B2

    G |- A2 <: A1 && G |- B1 <: B2
    ------------------------------ :: Arrow
    G |- A1 -> B1 <: A2 -> B2

    G, X <: A |- B1 <: B2
    ----------------------------------------- :: Forall
    G |- Forall (X <: A).B1 <: Forall (X <: A).B2

defn
    G |- t : A :: :: type :: ''
    {{tex [[G]] \vdash [[t]] : [[A]] }} by
    
    x : A elem G && G Ok
    -------------------- :: varP
    G |- x : A

    ------------------------------------ :: Box
    G |- box : Forall (X <: SL).(X -> ?)
    
    --------------------------------------- :: Unbox
    G |- unbox : Forall (X <: SL).(? -> X)

    G Ok
    ---------------------- :: squashP
    G |- squash U : U -> ?

    G Ok
    --------------------- :: splitP
    G |- split U : ? -> U

    G Ok
    ---------------- :: unitP
    G |- triv : Unit

    G Ok
    ------------- :: zeroP
    G |- 0 : Nat

    G |- t : Nat
    ----------------- :: succ
    G |- succ t : Nat    

    G |- t : Nat
    G |- t1 : A && G, x : Nat |- t2 : A
    ------------------------------------------- :: ncase
    G |- ncase t of 0 -> t1, (succ x) -> t2 : A

    G Ok && G |- A : *
    -------------------------------- :: empty
    G |- [] : Forall (X <: Top).List X

    G |- t1 : A && G |- t2 : List A
    ------------------------------- :: cons
    G |- t1 :: t2 : List A

    G |- t : List A
    G |- t1 : B && G, x : A, y : List A |- t2 : B
    --------------------------------------------- :: lcase
    G |- lcase t of [] -> t1, (x :: y) -> t2 : B

    G |- t1 : A1 && G |- t2 : A2
    ---------------------------- :: pair
    G |- (t1,t2) : A1 x A2

    G |- t : A1 x A2
    ---------------- :: fst
    G |- fst t : A1

    G |- t : A1 x A2
    ---------------- :: snd
    G |- snd t : A2

    G, x : A |- t : B
    -------------------- :: lam
    G |- \x:A.t : A -> B

    G |- t1 : A -> B && G |- t2 : A
    ---------------------------------- :: app
    G |- t1 t2 : B

    G, X <: A |- t : B
    ------------------------------------ :: Lam
    G |- Lam X <: A. t : Forall (X <: A).B

    G |- t : Forall (X<:B).C && G |- A <: B
    --------------------------------------- :: typeApp
    G |- [A]t : [A/X]C

    G |- t : A && G |- A <: B
    ------------------------- :: Sub
    G |- t : B

defns
  Reduction :: '' ::=

defn
    t1 ~> t2 :: :: red :: rd_    
by

    . |- t : A
    ------------------------- :: retracT
    unbox A (box B t) ~> t

    . |- t : U
    ------------------------- :: retractU
    split U (squash U t) ~> t

    t ~> t'
    ----------------- :: succ
    succ t ~> succ t'

    ---------------------------------------- :: ncase0
    ncase 0 of 0 -> t1, (succ x) -> t2 ~> t1

    ---------------------------------------------------- :: ncaseSucc
    ncase (succ t) of 0 -> t1, (succ x) -> t2 ~> [t/x]t2

    t ~> t'
    ------------------------------------------------------------------------- :: ncase1
    ncase t of 0 -> t1, (succ x) -> t2 ~> ncase t' of 0 -> t1, (succ x) -> t2

    t1 ~> t'1
    ------------------------------------------------------------------------- :: ncase2
    ncase t of 0 -> t1, (succ x) -> t2 ~> ncase t of 0 -> t'1, (succ x) -> t2

    t2  ~> t'2
    ------------------------------------------------------------------------- :: ncase3
    ncase t of 0 -> t1, (succ x) -> t2 ~> ncase t of 0 -> t1, (succ x) -> t'2


    ------------------------------------------ :: lcaseEmpty
    lcase [] of [] -> t1, (x :: y) -> t2 ~> t1

    -------------------------------------------------------------- :: lcaseCons
    lcase (t1 :: t2) of [] -> t3, (x :: y) -> t4 ~> [t1/x][t2/y]t4

    t1 ~> t'1
    --------------------- :: head
    t1 :: t2 ~> t'1 :: t2

    t2 ~> t'2
    --------------------- :: tail
    t1 :: t2 ~> t1 :: t'2

    t ~> t'
    --------------------------------------------------------------------------- :: lcase1
    lcase t of [] -> t1, (x :: y) -> t2 ~> lcase t' of [] -> t1, (x :: y) -> t2

    t1 ~> t'1
    --------------------------------------------------------------------------- :: lcase2
    lcase t of [] -> t1, (x :: y) -> t2 ~> lcase t of [] -> t'1, (x :: y) -> t2

    t2 ~> t'2
    --------------------------------------------------------------------------- :: lcase3
    lcase t of [] -> t1, (x :: y) -> t2 ~> lcase t of [] -> t1, (x :: y) -> t'2

    ------------------------- :: beta
    (\x:A1.t2) t1 ~> [t1/x]t2

    x nin FV(t)
    ----------------- :: eta
    \x:A1.H(t x) ~> t
    
    ------------------ :: proj1
    fst (t1, t2) ~> t1

    ------------------ :: proj2
    snd (t1, t2) ~> t2
    
    ------------------- :: etaP
    (fst t, snd t) ~> t

    t ~> t'
    ----------------- :: lam
    \x:A.t ~> \x:A.t'

    t1 ~> t'1
    --------------- :: app1
    t1 t2 ~> t'1 t2

    t2 ~> t'2
    --------------- :: app2
    t1 t2 ~> t1 t'2

    t ~> t'
    --------------- :: fst
    fst t ~> fst t'

    t ~> t'
    --------------- :: snd
    snd t ~> snd t'

    t1 ~> t'1
    ------------------- :: pair1
    (t1,t2) ~> (t'1,t2)

    t2  ~> t'2
    ------------------- :: pair2
    (t1,t2) ~> (t1,t'2)

    ----------------------------- :: typeBeta
    [A](Lam X <: B . t) ~> [A/X]t

    t1 ~> t2
    -------------- :: typeApp
    [A]t1 ~> [A]t2

    t1 ~> t2
    ------------------------------ :: Lam
    Lam X <: A.t1 ~> Lam X <: A.t2