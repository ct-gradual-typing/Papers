\cite{Scott:1980} showed how to model the untyped $\lambda$-calculus
within a cartesian closed category, $\cat{C}$, with a distinguished
object we will call $[[?]]$ -- read as the type of untyped terms --
such that the object\footnote{We will use the terms ``object'' and
  ``type'' interchangeably.} $[[? ->?]]$ is a retract of $?$.  That
is, there are morphisms $[[squash : (? -> ?)  --> ?]]$ and $[[split :
    ?  --> (? -> ?)]]$ where $[[squash]];[[split]] = \id : [[(? -> ?)
    --> (? -> ?)]]$\footnote{We denote composition of morphisms by
  $f;g : A \mto C$ given morphisms $f : A \mto B$ and $g : B \mto
  C$.}.  For example, taking these morphisms as terms in the typed
$\lambda$-calculus we can define the prototypical looping term
$(\lambda x.x\,x)(\lambda x.x\,x)$ by
$[[(\x:?.H((split x) x))(squash (\x:?.H((split x) x)))]]$.

In the same volume as Scott \cite{Lambek:1980} showed that cartesian
closed categories also model the typed $\lambda$-calculus. Suppose we
want to model the typed $\lambda$-calculus with pairs and natural
numbers.  That is, given two types $[[A1]]$ and $[[A2]]$ there is a
type $[[A1 x A2]]$, and there is a type $[[Nat]]$.  Furthermore, we
have first and second projections, and zero and successor
functions. This situation can easily be modeled by a cartesian closed
category $\cat{C}$ -- see Section~\ref{sec:categorical_model} for the
details -- but also add to $\cat{C}$ the type of untyped terms
$[[?]]$, $[[squash]]$, and $[[split]]$. At this point $\cat{C}$ is a
model of both the typed and the untyped $\lambda$-calculus.  However,
the two theories are really just sitting side by side in $\cat{C}$ and
cannot really interact much.

Suppose $\cat{T}$ is a discrete category with the objects $[[Nat]]$
and $[[Unit]]$ (the terminal object or empty product) and $\T :
\cat{T} \mto \cat{C}$ is a full and faithful functor.  This implies
that $\cat{T}$ is a subcategory of $\cat{C}$, and that $\cat{T}$ is
the category of atomic types.  Then for any type $A$ of $\cat{T}$ we
add to $\cat{C}$ the morphisms $[[box]] : \T A \mto [[?]]$ and
$[[unbox]] :\, ? \mto \T A$ such that $[[box]];[[unbox]] = \id : \T A
\mto \T A$ making $\T A$ a retract of $[[?]]$.  This is the bridge
allowing the typed world to interact with the untyped one.  We can
think of $[[box]]$ as injecting typed data into the untyped world, and
$[[unbox]]$ as taking it back.  Notice that the only time we can
actually get the typed data back out is if it were injected into the
untyped world initially.  In the model this is enforced through
composition, but in the language this will be enforced at runtime, and
hence, requires the language to contain dynamic typing.  Thus, what we
have just built up is a categorical model that offers a new
perspective of how to combine static and dynamic typing.

\cite{Siek:2006} define gradual typing to be the combination of both
static and dynamic typing that allows for the programmer to program in
dynamic style, and thus, annotations should be suppressed.  This means
that a gradually typed program can utilize both static types which
will be enforced during compile time, but may also utilize dynamic
typing that will be enforced during runtime.  Therefore, gradual
typing is the best of both worlds.

Siek and Taha's gradually typed functional language is the typed
$\lambda$-calculus with the type of untyped terms $[[?]]$ and the
following rules:
\begin{mathpar}
  \SLGradydruleappU{} \and
  \SLGradydruleappC{} \and
\end{mathpar}
The premise $[[A ~ B]]$ is read, the type $[[A]]$ is consistent with
the type $[[B]]$, and is defined in Figure~\ref{fig:type-consistency}.
If we squint we can see $[[split]]$, $[[squash]]$, $[[box]]$, and
$[[unbox]]$ hiding in the definition of the previous rules, but they
have been suppressed.  We will show that when one uses either of the
two typing rules then one is really implicitly using a casting
morphism built from $[[split]]$, $[[squash]]$, $[[box]]$, and
$[[unbox]]$.  In fact, the consistency relation $[[A ~ B]]$ can be
interpreted as such a morphism.  Then the typing above can be read
semantically as a saying if a casting morphism exists, then the type
really can be converted into the necessary type.

\paragraph{Contributions.} This paper offers the following contributions:
\begin{itemize}

\item A new categorical model for gradual typing for functional
  languages.  We show how to interpret \cite{Siek:2006}'s gradual type
  system in the categorical model outlined above.  As far as the
  authors are aware this is the first categorical model for gradual
  typing.

\item We then extract a functional programming language called Grady
  from the categorical model via the Curry-Howard-Lambek
  correspondence.  This is not a gradual type system, but can be seen
  as an alternative annotated language in which Siek and Taha's
  gradual type system can be translated to.
  
\item A proof that Grady is as expressive as \cite{Siek:2006}'s
  annotated language and vice versa. We give a type directed
  translation of Siek and Taha's annotated language to Grady and vice
  versa, then we show that these translations preserve evaluation.

\item Having the untyped $\lambda$-calculus along side the typed
  $\lambda$-calculus can be a lot of fun.  We show how to Church
  encode typed data, utilize the Y-combinator, and even obtain
  terminating recursion on natural numbers by combining the
  Y-combinator with a natural number eliminator.  Thus, obtaining the
  expressive power of G\"odel's system T \cite{Girard:1989}.
\end{itemize}

\paragraph{Related work.} TODO

%%% Local Variables: ***
%%% mode:latex ***
%%% TeX-master: "main.tex"  ***
%%% End: ***
