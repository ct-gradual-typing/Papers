The strength and main motivation for giving a categorical model to a
programming language is that it can expose the fundamental structure
of the language.  This arises because a lot of the language features
that often cloud the picture go away, for example, syntactic notions
like variables disappear.  This can often simplify things and expose
the underlying structure.  Reynolds \cite{?} was a big advocate for
the use of category theory in programming language research for these
reasons.  For example, when giving the simply typed $\lambda$-calculus
a categorical model we see that it is a cartesian closed category, but
we also know that intuitionistic logic has the same model due to
\cite{Lambek:1980}; on the syntactic side these two theories are
equivalent as well due to \cite{Howard:1980}. Thus, the fundamental
structure of the simply typed $\lambda$-calculus is intuitionistic
logic.  This also shows a relationship between seemingly unrelated
theories.  It is quite surprising that these two theories are related.
Another more recent example of this can be found in the connection
between dependent type theory and homotopy theory \cite{??}.

Another major benefit of studying the categorical model of programming
languages is that it gives us a powerful tool to study language
extensions.  For example, purely functional programming in Haskell
would not be where it is without the seminal work of Moggi and Wadler
\cite{??}  on using monads -- a purely categorical notion -- to add
side effects to Haskell.  Thus, we believe that developing these types
of models for new language designs and features can be hugely
beneficial.

Interpreting a programming language into a categorical model requires
three steps.  First, the types are interpreted as objects.  Then
programs are interpreted as morphisms in the category, but this is a
simplification.  Every morphism, $f$, in a category has a source
object and a target object, we usually denote this by $f : A \mto B$.
Thus, in order to interpret programs as morphisms the program must
have a source and target.  So instead of interpreting raw terms as
morphisms we interpret terms in their typing context.  That is, we
must show how to interpret every $[[G |- t : A]]$ as a morphism $[[t]]
: \interp{[[G]]} \mto \interp{[[A]]}$.  The third step is to show that
whenever one program reduces to another their interpretations are
isomorphic in the model. This means that whenever $[[G |- t1 ~> t2 :
    A]]$, then $[[ [|t1|] ]] = [[ [|t2|] ]] : [[ [| G |] --> [| A
      |] ]]$.  This is the reason why we defined our reduction in a
typed fashion to aid us in understanding how it relates to the model.
For a more thorough introduction see \cite{Crole:1994}.

\subsection{The Categorical Model}
\label{subsec:the_categorical_model}
We now give a categorical model for $\lambda^?_\to$ and
$\lambda^{\langle [[A]] \rangle}_\to$.  The model we develop here
builds on the seminal work of \cite{Lambek:1980} and
\cite{Scott:1980}.  \cite{Lambek:1980} showed that the typed
$\lambda$-calculus can be modeled by a cartesian closed category.  In
the same volume as Lambek, Scott essentially showed that the untyped
$\lambda$-calculus is actually typed.  That is, typed theories are
more fundamental than untyped ones.  He accomplished this by adding a
single type, $[[?]]$, and two functions $[[squash : (? -> ?) -> ?]]$
and $[[split : ? -> (?  -> ?)]]$, such that, $[[squash]];[[split]] =
\id : [[(? -> ?) -> (?  -> ?)]]$. At this point he was able to
translate the untyped $\lambda$-calculus into this unityped one.
Categorically, he modeled $[[split]]$ and $[[squash]]$ as the
morphisms in a retract within a cartesian closed category -- the same
model as typed $\lambda$-calculus.

\begin{definition}
  \label{def:retract}
  Suppose $\cat{C}$ is a category.  Then an object $A$ is a
  \textbf{retract} of an object $B$ if there are morphisms $i : A \mto
  B$ and $r : B \mto A$ such that the following diagram commutes:
  \[
  \bfig
  \qtriangle/->`=`->/[A`B`A;i``r]
  \efig
  \]
\end{definition}
Thus, $[[? -> ?]]$ is a retract of $[[?]]$, but we extend this
slightly to include $[[? x ?]]$ being a retract of $[[?]]$.  This is
only a slight extension of Scott's model, because our languages will
have products where he did not consider products, because he was
considering the traditional definition of the untyped
$\lambda$-calculus.

We can now define our categorical model of the untyped
$\lambda$-calculus with products.
\begin{definition}
  \label{def:model-untyped}
  An \textbf{untyped $\lambda$-model}, $(\cat{C}, ?, \split,
  \squash)$, is a cartesian closed category $\cat{C}$ with a
  distinguished object $?$ and morphisms $\squash : S \mto ?$ and
  $\split : ? \mto S$ making the object $S$ a retract of $?$, where
  $S$ is either $[[? -> ?]]$ or $[[? x ?]]$.
\end{definition}

\begin{theorem}[\citet{Scott:1980}]
  \label{thm:untyped-lambda-model-sound-complete}
  An untyped $\lambda$-model is a sound and complete model of the untyped $\lambda$-calculus.
\end{theorem}

Since all of the languages we are studying here contain the natural
numbers we must be able to interpret them into our model.  We give a
novel approach to modeling the natural numbers with their
(non-recursive) eliminator using what we call a Scott natural number
object.  Now the natural number eliminator is not part of
$\lambda^?_\to$ or $\lambda^{\langle [[A]] \rangle}_\to$, but we want
Grady to contain it, and Grady will directly correspond to the model.
\begin{definition}
  \label{def:SNNO}
  Suppose $\cat{C}$ is a cartesian closed category.  A
  \textbf{Scott natural number object (SNNO)} is an object $[[Nat]]$ of $\cat{C}$ and
  morphisms $\mathsf{z} : 1 \mto [[Nat]]$ and $[[succ]] : [[Nat]]  \mto [[Nat]]$ of $\cat{C}$,
  such that, for any morphisms $f : [[Y]] \mto X$ and $g : [[Y x Nat]] \mto X$ of $\cat{C}$ there is a unique morphism
  $\case_X : [[Y x Nat]] \mto X$ making the following diagrams commute:
       \[
       \begin{array}{lll}
         \bfig
         \qtriangle|amm|<1000,500>[
           [[Y x Nat]]`
           [[Y x Nat]]`
           X;
           \id_Y \times \mathsf{z}`
           \pi_1;f`
           \case_X]

         \ptriangle(1000,0)|amm|/<-`->`->/<1000,500>[
           [[Y x Nat]]`
           [[Y x Nat]]`
           X;
           \id_Y \times [[succ]]`
           \case_X`
           g ]
         \efig                               
       \end{array}
       \]
       Informally, the two diagrams essentially assert that we can
       define $\case_X$ as follows:
       \begin{center}
         \begin{math}
           \begin{array}{rll}
             \case_X\,y\,0 & = & f\,y\\
             \case_X\,y\,[[(succ x)]] & = &  g\,y\,x
           \end{array}
         \end{math}
       \end{center}
\end{definition}
\noindent This formalization of natural numbers is inspired by the
definition of Scott Numerals \cite{??} where the notion of a case
distinction is built into the encoding. We can think of $[[Y]]$ in the
source object of $\case$ as the type of additional inputs that will be
passed to both $f$ and $g$, but we can think of $[[Nat]]$ in the
source object of $\case$ as the type of the scrutiny.  Thus, since in
the base case there is no predecessor, $f$, will not require the
scrutiny, and so it is ignored.

One major difference between SNNOs and the more traditional natural
number objects is that in the definition of the latter $g$ is defined
by well-founded recursion.  However, SNNOs do not allow this, but in
the presence of fixpoints we are able to regain this feature without
having to bake it into the definition of natural number objects.
However, to allow this we have found that when combining fixpoints and
case analysis to define terminating functions on the natural numbers
it is necessary to uniformly construct the input to both $f$ and $g$
due to the reduction rule of the Y combinator.  Thus, we extend the
type of $f$ to $[[Y x Nat]]$, but then ignore the second projection
when reaching the base case.

So far we can model the untyped and the typed $\lambda$-calculi within
a cartesian closed category, but we do not have any way of moving
typed data into the untyped part and vice versa.  To accomplish this
we add two new morphisms $[[box C : C --> ?]]$ and $[[unbox C : ? -->
    C]]$ such that $[[box C]];[[unbox C]] = \id : C \mto C$ for every
atomic type $[[C]]$.  Thus, each atomic type is a retract of $[[?]]$.
This enforces that the only time we can really consider something as
typed is if it were boxed up in the first place.  We can look at this
from another perspective as well.  If the programmer tries to unbox
something that is truly untyped, then their program may actually type
check, but they will obtain a dynamic type error at runtime, because
the unbox will never have been matched up with the correct boxed data.
For example, we can cast $3$ to type $\mathsf{Bool}$ by
$[[unbox]]_{\mathsf{Bool}} ([[box Nat]]\, 3)$, but if this program is
every run, then we will obtain a dynamic type error.  Note that we can
type the previous program in $\lambda^{\langle [[A]] \rangle}_\to$ as
well, but if we run the program it will result in a dynamic type error
too.

Now we combine everything we have discussed so far to obtain the
categorical model.
\begin{definition}
  \label{def:gradual-lambda-model}
  A \textbf{gradual $\lambda$-model}, $(\cat{T}, \cat{C}, ?, \T,
  \split,\squash, \bx,$ $\unbox)$, where $\cat{T}$ is a discrete
  category with at least two objects $[[Nat]]$ and $[[Unit]]$,
  $\cat{C}$ is a cartesian closed category with a SNNO,
  $(\cat{C},?,\split,$ $\squash)$ is an untyped $\lambda$-model, $\T :
  \cat{T} \mto \cat{C}$ is an embedding -- a full and faithful functor
  that is injective on objects -- and for every object $A$ of
  $\cat{T}$ there are morphisms $\bx_A : TA \mto ?$ and $\unbox_A : ?
  \mto TA$ making $TA$ a retract of $?$.
\end{definition}
\noindent
We call the category $\cat{T}$ the category of atomic types.  We call
an object, $[[A]]$, \textbf{atomic} iff there is some object $[[A']]$
in $\cat{T}$ such that $[[A]] = \T[[A']]$. Note that we do not
consider $[[?]]$ an atomic type.  The model really is the cartesian
closed category $\cat{C}$, but it is extended with the structure of
both the typed and the untyped $\lambda$-calculus with the ability to
cast data.

Interpreting the typing rules for $\lambda^?_\to$ will require the
interpretation of type consistency.  Thus, we must be able to cast any
type $[[A]]$ to $[[?]]$, but as stated the model only allows atomic
types to be casted.  It turns out that this can be lifted to any type.

We call any morphism defined completely in terms of $\id$, the functors
$- \times -$ and $- \to -$, $[[split]]$ and $[[squash]]$, and
$[[box]]$ and $[[unbox]]$ a \textbf{casting morphism}. To cast any
type $[[A]]$ to $[[?]]$ we will build casting morphisms that first
take the object $[[A]]$ to its skeleton, and then takes the skeleton
to $[[?]]$.
\begin{definition}
  \label{def:skeleton}
  Suppose $(\cat{T}, \cat{C}, ?, \T, \split,\squash, \bx,$ $\unbox)$
  is a gradual $\lambda$-model.  Then the \textbf{skeleton} of an
  object $[[A]]$ of $\cat{C}$ is an object $[[S]]$ that is constructed
  by replacing each atomic type in $[[A]]$ with $[[?]]$. Given an
  object $[[A]]$ we denote its skeleton by $[[skeleton A]]$.
\end{definition}
One should think of the skeleton of an object as the supporting type
structure of the object, but we do not know what kind of data is
actually in the structure. For example, the skeleton of the object
$[[Nat]]$ is $[[?]]$, and the skeleton of $[[(Nat x Unit) -> Nat ->
    Nat]]$ is $[[(?  x ?) -> ? -> ?]]$.

The next definition defines a means of constructing a casting morphism
that casts a type $[[A]]$ to its skeleton and vice versa.  This
definition is by mutual recursion on the input type.
\begin{definition}
  \label{def:boxing-unboxing}
  Suppose $(\cat{T}, \cat{C}, ?, \T, \split,\squash, \bx,$ $\unbox)$
  is a gradual $\lambda$-model.  Then for any object $[[A]]$ whose
  skeleton is $[[S]]$ we define the morphisms
  $[[lbox A]] : [[A --> S]]$ and
  $[[lunbox A]] : [[S --> A]]$ by mutual recursion on
  $[[A]]$ as follows:
  \[
  \begin{array}{ll|ll}
    \begin{array}{lll}
      [[lbox A]] = [[box A]]\\
    \,\,\,\,\text{when } [[A]]\text{ is atomic}\\
    \\
    [[lbox ?]] = \id_{[[?]]}\\
    \\
    [[lbox (A1 -> A2)]] = [[lunbox A1]] \to [[lbox A2]]\\
    \\
    [[lbox (A1 x A2)]] = [[lbox A1]] \times [[lbox A2]]\\        
    \end{array}
    & & \quad & 
    \begin{array}{lll}
    [[lunbox A]] = [[unbox A]]\\
    \,\,\,\,\text{when } [[A]]\text{ is atomic}\\
    \\
    [[lunbox ?]] = \id_{[[?]]}\\
    \\
    [[lunbox (A1 -> A2)]] = [[lbox A1]] \to [[lunbox A2]]\\
    \\
    [[lunbox (A1 x A2)]] = [[lunbox A1]] \times [[lunbox A2]]\\        
    \end{array}
  \end{array}
  \]
\end{definition}
\noindent
The definition of both $\widehat{[[box]]}$ or $\widehat{[[unbox]]}$
uses the functor $- \to - : \catop{C} \times \cat{C} \mto \cat{C}$
which is contravariant in its first argument, and thus, in that
contravariant position we must make a recursive call to the opposite
function, and hence, they must be mutually defined. Every call to
either $\widehat{[[box]]}$ or $\widehat{[[unbox]]}$ in the previous
definition is on a smaller object than the input object.  Thus, their
definitions are well founded.  Furthermore, $\widehat{[[box]]}$ and
$\widehat{[[unbox]]}$ form a retract between $[[A]]$ and $[[S]]$.
\begin{lemma}[Boxing and Unboxing Lifted Retract]
  \label{lemma:lifted_retract}
  Suppose $(\cat{T}, \cat{C}, ?, \T, \split,\squash, \bx,$ $\unbox)$
  is a gradual $\lambda$-model.  Then for any object $[[A]]$,
  \[ [[lbox A]];[[lunbox A]] = \id_A : [[A --> A]]. \]
\end{lemma}
\begin{proof}  
  This proof holds by induction on the form $[[A]]$.  Please see
  Appendix~\ref{subsec:proof_of_lifted_retract} for the complete
  proof.
\end{proof}

As an example, suppose we wanted to cast the type $[[(Nat x ?) ->
    Nat]]$ to its skeleton $[[(? x ?) -> ?]]$.  Then we can obtain a
casting morphisms that will do this as follows:
\[
\begin{array}{lll}
  [[lbox ((Nat x ?) -> Nat)]]
  & = & [[lunbox (Nat x ?)]] \to [[lbox Nat]]\\
  & = & ([[lunbox Nat]] \times [[lunbox ?]]) \to [[lbox Nat]]\\
  & = & ([[unbox Nat]] \times \id_{[[?]]}) \to [[box Nat]]\\
\end{array}
\]
We can also cast a morphism $[[A]] \mto^f [[B]]$ to a morphism
\[ [[S1]] \mto^{[[lunbox A]]} A \mto^{f} B \mto^{[[lbox B]]} [[S2]]\]
where $[[S1]] = [[skeleton A]]$ and $[[S2]] = [[skeleton B]]$.  Now if
we have a second
\[ [[S2]] \mto^{[[lunbox B]]} B \mto^{g} C \mto^{[[lbox C]]} [[S3]]\]
then their composition reduces to composition at the typed level:
\[
\bfig
\square|amma|/->`->`->`<-/<500,500>[
  [[S1]]`
  [[A]]`
  [[S3]]`
  [[C]];
  [[lunbox A]]``
  f;g`
  [[lbox C]]
]

\square(500,0)|amma|/->`->`=`<-/<500,500>[
  [[A]]`
  [[B]]`
  [[C]]`
  [[B]];
  f`
  f;g``
  g]

\square(1000,0)|amma|/->`=`=`<-/<500,500>[
  [[B]]`
  [[S2]]`
  [[B]]`
  [[S2]];
  [[lbox B]]```
  [[lunbox B]]
] 
\efig
\]
The right most diagram commutes because $[[B]]$ is a retract of
$[[S2]]$, and the left unannotated arrow is the composition $[[lunbox
    A]];f;g;[[lbox C]]$.  This tells us that we have a functor $\S
: \cat{C} \mto \cat{S}$:
\[
\begin{array}{lll}
  \S[[A]] = [[skeleton A]]\\
  \S (f : [[A --> B]]) = [[lunbox A]];f;[[lbox A]]
\end{array}
\]
where $\cat{S}$ is the full subcategory of $\cat{C}$ consisting of the
skeletons and morphisms between them, that is, $\cat{S}$ is a
cartesian closed category with one basic object $[[?]]$ such that
$(\cat{S},[[?]],[[split]],[[squash]])$ is an untyped $\lambda$-model.
The following turns out to be true.
\begin{lemma}[$\S$ is faithful]
  \label{lemma:S_is_faithful}
  Suppose $(\cat{T}, \cat{C}, ?, \T, \split,\squash, \bx,$ $\unbox)$
  is a gradual $\lambda$-model, and
  $(\cat{S},[[?]],[[split]],[[squash]])$ is the category of skeletons.
  Then the functor $\S : \cat{C} \mto \cat{S}$ is faithful.
\end{lemma}
\begin{proof}
  This proof follows from the definition $\S$ and
  Lemma~\ref{lemma:lifted_retract}.  For the full proof see
  Appendix~\ref{subsec:proof_of_S_is_faithful}.
\end{proof}
Thus, we can think of the functor $\S$ as an injection of the typed
world into the untyped one.

Now that we can cast any type into its skeleton we must show that
every skeleton can be cast to $[[?]]$.  We do this similarly to the
above and lift $[[split]]$ and $[[squash]]$ to arbitrary skeletons.
\begin{definition}
  \label{def:lifted-split-squash}
  Suppose $(\cat{S}, [[?]], [[split]],[[squash]])$ is the category of
  skeletons.  Then for any skeleton $[[S]]$ we define the morphisms
  $[[lsquash S]] : [[S --> ?]]$ and $[[lsplit S]] : [[? --> S]]$ by
  mutual recursion on $[[S]]$ as follows:
  \[
    \begin{array}{ll|ll}
      \begin{array}{lll}
        [[lsquash ?]] = \id_?\\
        \\
        [[lsquash (S1 -> S2)]] = ([[lsplit S1]] \to [[lsquash S2]]);[[squash ? -> ?]]\\
        \\
        [[lsquash (S1 x S2)]] = ([[lsquash S1]] \times [[lsquash S2]]);[[squash ? x ?]]\\
      \end{array}
      & & \quad &
      \begin{array}{lll}
        [[lsplit ?]] = \id_?\\
        \\
        [[lsplit (S1 -> S2)]] = [[split ? -> ?]];([[lsquash S1]] \to [[lsplit S2]])\\
        \\
        [[lsplit (S1 x S2)]] = [[split ? x ?]];([[lsplit S1]] \times [[lsplit S2]])\\      
      \end{array}
    \end{array}  
  \]
\end{definition}
\noindent
As an example we will construct the casting morphism that casts the
skeleton $[[(? x ?) -> ?]]$ to $[[?]]$:
\[
\begin{array}{lll}
  [[lsquash (? x ?) -> ?]]
  & = & ([[lsplit ? x ?]] \to [[lsquash ?]]);[[squash ? -> ?]]\\
  & = & ([[split ? x ?]];([[lsplit ?]] \times [[lsplit ?]])) \to [[lsquash ?]]);[[squash ? -> ?]]\\
  & = & (([[split ? x ?]];(\id_? \times \id_?)) \to \id_?);[[squash ? -> ?]]\\
  & = & ([[split ? x ?]] \to \id_?);[[squash ? -> ?]]\\
\end{array}
\]
\noindent
The morphisms $[[lsplit S]]$ and $[[lsquash S]]$ form a retract
between $[[S]]$ and $[[?]]$.

\begin{lemma}[Splitting and Squashing Lifted Retract]
  \label{lemma:lifted_retract_for_?}
  Suppose $(\cat{S}, [[?]], [[split]],[[squash]])$ is the category of
  skeletons.  Then for any skeleton $[[S]]$,
  \[
    [[lsquash A]];[[lsplit A]] = \id_A : [[A --> A]]
  \]
\end{lemma}
\begin{proof}
  The proof is similar to the proof of the boxing and unboxing lifted
  retract (Lemma~\ref{lemma:lifted_retract}).
\end{proof}
There is also a faithful functor from $\cat{S}$ to $\cat{U}$ where
$\cat{U}$ is the full subcategory of $\cat{S}$ that consists of the
single object $[[?]]$ and all its morphisms between it:
\[
\begin{array}{lll}
  \U S = ?\\
  \U (f : [[S1 --> S2]]) = [[lsplit S1]];f;[[lsquash S2]]
\end{array}
\]
This finally implies that there is a functor $\C : \cat{C} \mto
\cat{U}$ that injects all of $\cat{C}$ into the object $[[?]]$.
\begin{lemma}[Casting to $[[?]]$]
  \label{lemma:casting_to_?}
  Suppose $(\cat{T}, \cat{C}, ?, \T, \split,\squash, \bx,$ $\unbox)$
  is a gradual $\lambda$-model, $(\cat{S},[[?]],[[split]],[[squash]])$
  is the full subcategory of skeletons, and $(\cat{U},[[?]])$ is the
  full subcategory containing only $[[?]]$ and its morphisms.  Then
  there is a faithful functor $\C = \cat{C} \mto^{\S} \cat{S} \mto^{\U} \cat{U}$.
\end{lemma}
\noindent
In a way we can think of $\C : \cat{C} \mto \cat{U}$ as a forgetful
functor.  It forgets the type information.

Getting back the typed information is harder.  There is no nice
functor from $\cat{U}$ to $\cat{C}$, because we need more information.
However, given a type $[[A]]$ we can always obtain a casting morphism
from $[[?]]$ to $[[A]]$ by $[[(lsplit (skeleton A))]];([[lunbox A]]) :
[[? --> A]]$.  Finally, we have the following result.
\begin{lemma}[Casting Morphisms to $[[?]]$]
  \label{lemma:casting_morphisms}
  Suppose $(\cat{T}, \cat{C}, ?, \T, \split, \squash, \bx, \unbox)$ is
  a gradual $\lambda$-model, and $[[A]]$ is an object of $\cat{C}$.
  Then there exists casting morphisms from $[[A]]$ to $[[?]]$ and vice
  versa that make $[[A]]$ a retract of $[[?]]$.
\end{lemma}
\begin{proof}
  The two morphisms are as follows:
  \[
  \begin{array}{lll}
    [[Box A]] := [[lbox A]];[[lsquash (skeleton A)]] : [[A --> ?]]\\
    \\
    [[Unbox A]] := [[lsplit (skeleton A)]];[[lunbox A]] : [[? --> A]]
  \end{array}
  \]
  The fact the these form a retract between $[[A]]$ and $[[?]]$ holds
  by Lemma~\ref{lemma:lifted_retract} and
  Lemma~\ref{lemma:lifted_retract_for_?}.
\end{proof}
% subsection the_categorical_model (end)

\subsection{The Interpretation}
\label{subsec:the_interpretation}
In this section we show how to interpret $\lambda^?_\to$ and
$\lambda^{\langle [[A]] \rangle}_\to$ into the categorical model given
in the previous section. We complete the three steps summarized
above. We will show how to interpret the typing of the former into the
model, and then show how to do the same for the latter, furthermore,
we show that reduction can be interpreted into the model as well, thus
concluding soundness for $\lambda^{\langle [[A]] \rangle}_\to$ with
respect to our model.

First, we must give the interpretation of types and contexts, but this
interpretation is obvious, because we have been making sure to match
the names of types and objects throughout this paper.
\begin{definition}
  \label{def:interpretation-of-gradual-types}
  Suppose $(\cat{T}, \cat{C}, ?, \T, \split, \squash, \bx, \unbox)$ is
  a gradual $\lambda$-model.  Then we define the interpretation of
  types into $\cat{C}$ as follows:
  \[
  \begin{array}{lll}
    [[ [| Unit |] ]] & = & 1\\
    [[ [| Nat |] ]] & = & [[Nat]]\\
    [[ [| ? |] ]] & = & [[?]]\\
    [[ [| A1 -> A2 |] ]] & = & [[ [| A1 |] -> [| A2 |] ]]\\
    [[ [| A1 x A2 |] ]] & = & [[ [| A1 |] x [| A2 |] ]]\\
  \end{array}
  \]
  We extend this interpretation to typing contexts as follows:
  \[
    \begin{array}{lll}
      [[ [| . |] ]] & = & 1\\
      [[ [| G,x : A |] ]] & = & [[ [| G |] x [| A |] ]]\\
    \end{array}
  \]
\end{definition}
\noindent Throughout the remainder of this paper we will drop the
interpretation symbols around types.

Before we can interpret the typing rules of $\lambda^?_\to$ and
$\lambda^{\langle [[A]] \rangle}_\to$ we must show how to interpret
the consistency relation from Figure~\ref{fig:type-consistency}.
These will correspond to casting morphisms.
\begin{lemma}[Type Consistency in the Model]
  \label{lemma:type_consistency_in_the_model}
  Suppose $(\cat{T}, \cat{C}, ?, \T,$ $\split, \squash, \bx, \unbox)$ is
  a gradual $\lambda$-model, and $[[A ~ B]]$ for some types $[[A]]$
  and $[[B]]$.  Then there are two casting morphisms $c_1 : [[ A --> B ]]$ and $c_2 : [[ B --> A ]]$.
\end{lemma}
\begin{proof}
This proof holds by induction on the form $[[A ~ B]]$ using the
morphisms $[[Box A]] : [[A --> ?]]$ and $[[Unbox A]] : [[? --> A]]$.
Please see
Appendix~\ref{subsec:proof_of_type_consistency_in_the_model} for the
complete proof.
\end{proof}

\begin{corollary}
  \label{corollary:type_consist_coro}
  Suppose $(\cat{T}, \cat{C}, ?, \T,$ $\split, \squash, \bx, \unbox)$ is
  a gradual $\lambda$-model.  Then we know the following:
  \begin{enumerate}[label=\roman*.,align=left]
  \item If $[[A1 -> B1 ~ A2 -> B2]]$, then there are casting morphisms:
    \[
    \begin{array}{lllll}
      c & = & c_1 \to c_2 : [[(A1 -> B1) --> (A2 -> B2)]]\\
      c' & = & c_3 \to c_4 : [[(A2 -> B2) --> (A1 -> B1)]]
    \end{array}
    \]
    where $c_1 : [[A2 --> A1]]$ and $c_2 : [[B1 --> B2]]$, and $c_3 :
    [[A1 --> A2]]$ and $c_4 : [[B2 --> B1]]$.
    
  \item If $[[A1 x B1 ~ A2 x B2]]$, then there are casting
    morphisms:
    \[
    \begin{array}{lll}
       c & = & c_1 \times c_2 : [[(A1 x B1) --> (A2 x B2)]]\\
      c' & = & c_3 \times c_4 : [[(A2 x B2) --> (A1 x B1)]]
    \end{array}
    \]
    where $c_1 : [[A1 --> A2]]$ and $c_2 : [[B1 --> B2]]$, and $c_3 :
    [[A2 --> A1]]$ and $c_4 : [[B2 --> B1]]$.
  \end{enumerate}
\end{corollary}
\begin{proof}
  This proof holds by the construction of the casting morphisms from
  the proof of the previous result, and the fact that the type
  consistency rules are unique for each type.
\end{proof}

Showing that both $c_1$ and $c_2$ exist corresponds to the fact that
$[[A ~ B]]$ is symmetric.  But, this interpretation is an over
approximation of type consistency, because type consistency is not
transitive, but function composition is.  Leaving type consistency
implicit in the model just does not make good sense categorically,
because it would break composition.  For example, if we have morphisms
$f : [[A --> ?]]$ and $g : [[B --> C]]$, then if we implicitly allowed
$[[?]]$ to be cast to $[[B]]$, then we could compose these two
morphisms, but this does not fit the definition of a category, because
it requires the target of $f$ to match the source of $g$, but this
just is not the case.  Thus, the explicit cast must be used to obtain
$f;[[lunbox B]];g$.

At this point we have everything we need to show our main result which
is that typing in both $\lambda^?_\to$ and $\lambda^{\langle [[A]]
  \rangle}_\to$, and evaluation in $\lambda^{\langle [[A]] \rangle}$
can be interpreted into the categorical model.

\begin{theorem}[Interpretation of Typing]
  \label{thm:interpretation_of_typing}
  Suppose $(\cat{T}, \cat{C}, ?, \T, \split,$ $\squash, \bx, \unbox)$
  is a gradual $\lambda$-model.  If $[[G |- t : A]]$ in either
  $\lambda^?_\to$ or $\lambda^{\langle [[A]] \rangle}_\to$, then there
  is a morphism $[[ [| t |] ]] : [[ [| G |] --> A ]]$ in $\cat{C}$.
\end{theorem}
\begin{proof}
  The proof holds by induction on the form of $[[G |- t : A]]$ and
  uses most of the results we have developed up to this point.  Please
  see Appendix~\ref{subsec:proof_of_interpretation_of_types} for the
  complete proof.
\end{proof}

\begin{theorem}[Interpretation of Evaluation]
  \label{thm:interpretation_of_evaluation}
  Suppose $(\cat{T}, \cat{C}, ?, \T,$ $\split, \squash, \bx, \unbox)$
  is a gradual $\lambda$-model.  If $[[G |- t1 ~> t2 : A]]$, then
  $[[ [| t1 |] ]] = [[ [| t2 |] ]] : [[ [| G |] --> A]]$.
\end{theorem}
\begin{proof}
  This proof holds by induction on the form of $[[G |- t1 ~> t2 :
      A]]$, and uses Theorem~\ref{thm:interpretation_of_typing},
  Lemma~\ref{lemma:type_consistency_in_the_model}, and
  Corollary~\ref{corollary:type_consist_coro}.  Please see
  Appendix~\ref{subsec:proof_of_interpretation_of_evaluation} for the
  complete proof.  
\end{proof}
% subsection the_interpretation (end)

%%% Local Variables: ***
%%% mode:latex ***
%%% TeX-master: "main.tex"  ***
%%% End: ***
