

metavar termvar, x, y , z ::=

indexvar index, k ::=

grammar
  t, v, s :: 't_' ::=                                {{ com term }}
    | x                   ::   :: var          {{ com variable }}
    | triv                ::   :: unit         {{ com unit }}
    | squash S            ::   :: inj          {{ com injection of the retract }}
    {{tex \mathsf{squash}_{[[S]]} }}
    | split S             ::   :: surj         {{ com surjection of the retract }}
    {{tex \mathsf{split}_{[[S]]} }}    
    | box C               ::   :: gen          {{ com generalize to the untyped universe }}
    {{tex \mathsf{box}_{[[C]]} }}    
    | unbox C             ::   :: spec         {{ com specialize the untyped universe to a specific type }}
    {{tex \mathsf{unbox}_{[[C]]} }}
    | < A > t             ::   :: cast         {{ com type cast }}
    {{tex \langle [[A]] \rangle [[t]] }}    
    | \ x : A . t         ::   :: abs          {{ com $\lambda$-abstraction }}
    {{tex \lambda [[x]] : [[A]] . [[t]] }}
    | t1 t2               ::   :: app          {{ com function application }}
    | ( t1 , t2 )         ::   :: pair         {{ com pair constructor }}
    | fst t               ::   :: proj1        {{ com first projection }}
    | snd t               ::   :: proj2        {{ com second projection }}
    | succ t              ::   :: successor    {{ com successor function }}
    | 0                   ::   :: zero         {{ com zero }}
    | ( t )               :: S :: parens
    | [ t1 / x ] t2       :: M :: subst
    | wrong               :: M :: wrong
    {{tex \mathsf{wrong} }}
    | H( t )              :: M :: hparens
    {{tex [[t]] }}
    | squash              :: M  :: injU   
    {{tex \mathsf{squash} }}
    | split               :: M  :: surjU
    {{tex \mathsf{split} }}
    | drop-cast t         :: M :: DropCast
    {{tex \mathsf{drop}\text{-}\mathsf{cast}\,[[t]] }}
    | 42                  :: M :: Forty2
    | 3                   :: M :: Three
    | [| t |]             :: M :: Interp
    {{tex \interp{[[t]]} }}

  % s :: 's_' ::= {{com simple values }}
  %   | x                   ::   :: var  
  %   | triv                ::   :: unit         {{ com unit }}
  %   | 0                   ::   :: zero         {{ com zero }}

  % v :: 'v_' ::= {{com values }}
  %   | x                   ::   :: var
  %   | triv                ::   :: unit         {{ com unit }}
  %   | 0                   ::   :: zero         {{ com zero }}
  %   | <?> s               ::   :: cast         {{ com untype cast }}
    
  h :: 'h_' ::= {{com head-normal forms}}
    | triv       :: :: triv
    | split S    :: :: split
    | squash S   :: :: squash
    | box C      :: :: box
    {{tex \mathsf{box}_{[[C]]} }}    
    | unbox C    :: :: unbox
    {{tex \mathsf{unbox}_{[[C]]} }}    
    | \ x : A . t :: :: abs
    {{tex \lambda [[x]] : [[A]] . [[t]] }}
    | ( t1 , t2 )  :: :: pair
    | fst t      :: :: fst
    | snd t      :: :: snd
    | succ t     :: :: suc
    | 0          :: :: zero

  T :: 'T_' ::=                                {{ com terminating types }}  
    | Unit                ::   :: unit         {{ com unit type }}
    {{tex 1 }}
    | Nat                 ::   :: nat          {{ com natural number type }}
    | T1 -> T2            ::   :: arrow        {{ com function type }}
    | T1 x T2             ::   :: Pairs        {{ com cartesian product type }}
    {{tex [[T1]] \times [[T2]] }} 
    | ( T )               :: S :: paren
    
  % S :: 'S_' ::=
  %   | ? -> ?        ::   :: arrow
  %   | ? x ?         ::   :: prod
  %   | H( S )        :: M :: hparen
  %   {{tex [[S]] }}
  %   | ( S )         :: M :: Paren

  % C :: 'C_' ::=                                {{ com atomic type }}  
  %   | Unit                ::   :: term         {{ com unit type }}
  %   {{tex 1}}
  %   | Nat                 ::   :: nat          {{ com natural number type }}
  %   {{tex \mathsf{Nat} }}

  A, B, C, S, X, Y, Z :: 'A_' ::=                                {{ com type }}  
    | Unit                ::   :: term         {{ com unit type }}
    {{tex 1}}
    | Nat                 ::   :: nat          {{ com natural number type }}
    {{tex \mathsf{Nat} }}    
    | ?                   ::   :: unitype      {{ com untyped universe }}
    | A1 -> A2            ::   :: arrow        {{ com function type }}
    | A1 x A2             ::   :: pair         {{ com cartesian product type }}
    {{tex [[A1]] \times [[A2]] }}     
    | ( A )               :: S :: paren
    | TypeError           :: M :: typeError
    {{tex \mathsf{TypeError} }}
    | H( A )              :: M :: hparen
    {{tex [[A]] }}
    | A1 --> A2           :: M :: Morph
    {{tex [[A1]] \mto [[A2]] }}
    | [| G |]             :: M :: InterpCtx
    {{tex \interp{[[G]]} }}
    | [| A |]             :: M :: InterpType
    {{tex \interp{[[A]]} }}
    | skeleton A          :: M :: Skeleton
    {{tex \mathsf{skeleton}\,[[A]] }}
    

  G {{ tex \Gamma }} :: G_ ::=                 {{ com typing context }}
    | .                   ::   :: emptyCtx     {{ com empty context }}
    {{tex \cdot }}    
    | G , x : A           ::   :: vn           {{ com cons }}
    | G , G'              :: M :: append       {{ com append }}

  terminals :: 'terminals_' ::=
    |  ->                 ::   :: arrow
    {{tex \rightarrow }}
    | |-                  ::   :: turnstile
    {{tex \vdash }}
    | |~                  ::   :: ndash
    {{tex \not \vdash }}    
    | succ                ::   :: succ
    {{tex \mathsf{succ} }}
    | ?                   ::   :: unitype
    | ~                   ::   :: cons
    {{tex \sim }}
    | ~U                  ::   :: conv
    {{tex \sim_U }}    
    | elem                ::   :: elem
    {{tex \in }}
    | ~>                  ::   :: red
    {{tex \rightsquigarrow }}
    | box        :: :: box
    {{tex \mathsf{box} }}
    | unbox        :: :: unbox
    {{tex \mathsf{unbox} }}
    | fst        :: :: fst
    {{tex \mathsf{fst} }}
    | snd        :: :: snd
    {{tex \mathsf{snd} }}                

  vd :: 'vd_' ::=
    | |- :: :: vdash
    | |~ :: :: ndash

  formula :: 'formula_' ::=
    | judgement           ::   :: judgement
    | ~ formula           ::   :: notj
    {{tex \lnot [[formula]] }}
    | x : A elem G        ::   :: xTelemG
    | formula1 && formula2 ::  :: Quad
    {{tex [[formula1]] \quad [[formula2]] }}
    | not formula         ::   :: not
    | ( formula )         :: S :: parens
    {{tex [[formula]] }}
    | x nin FV ( t )      :: M :: FV
    {{tex [[x]] \not\in \mathsf{FV}([[t]]) }}
    | t != t'             :: M :: NeqT
    {{tex [[t]] \neq [[t']] }}
    | t : A               :: M :: TermHasType
    | A1 != A2            :: M :: TypeNEq
    {{tex [[A1]] \neq [[A2]] }}

subrules
  h <:: t
  T <:: A
  
defns
  Typing :: '' ::=

defn
    A ~ B :: :: typeConsis :: ''    {{ com [[A]] is consistent with [[B]] }}
    {{tex [[A]] \sim [[B]] }} by

    ----- :: refl
    A ~ A

    ----- :: box
    A ~ ?

    ----- :: unbox
    ? ~ A

    A1 ~ A2 && B1 ~ B2
    ------------------- :: arrow
    A1 -> B1 ~ A2 -> B2

    A1 ~ A2 && B1 ~ B2
    ------------------- :: prod
    A1 x B1 ~ A2 x B2
    
defn
    G vd t : A :: :: type :: ''    {{ com [[t]] has type [[A]] in context [[G]] }}
    {{tex [[G]] [[vd]] [[t]] : [[A]] }} by
    

    x : A elem G
    ------------ :: var
    G |- x : A

    ------------------- :: Box
    G |- box C : C -> ?

    --------------------- :: Unbox
    G |- unbox C : ? -> C

    ---------------------- :: squash
    G |- squash S : S -> ?

    --------------------- :: split
    G |- split S : ? -> S

    ---------------- :: unit
    G |- triv : Unit

    ------------- :: zero
    G |- 0 : Nat

    G |- t : Nat
    ----------------- :: succ
    G |- succ t : Nat

    G |- t1 : A1 && G |- t2 : A2
    ---------------------------- :: pair
    G |- (t1,t2) : A1 x A2

    G |- t : A1 x A2
    ---------------- :: fst
    G |- fst t : A1

    G |- t : A1 x A2
    ---------------- :: snd
    G |- snd t : A2

    G, x : A1 |- t : A2
    ----------------------- :: lam
    G |- \x:A1.t : A1 -> A2

    G |- t1 : A1 -> A2 && G |- t2 : A1
    ---------------------------------- :: app
    G |- t1 t2 : A2

% Gradual Siek16:

    G |- t : ?
    -------------- :: succU
    G |- succ t : ?

    G |- t : ?
    -------------- :: fstU
    G |- fst t : ?

    G |- t : ?
    -------------- :: sndU
    G |- snd t : ?

    G |- t1 : ? && G |- t2 : A
    -------------------------- :: appU
    G |- t1 t2 : ?
    
    G |- t1 : A1 -> B
    G |-t2 : A2 && A1 ~ A2
    ---------------------- :: appC
    G |- t1 t2 : B

    G |- t : A1 x B && A1 ~ A2
    -------------------------- :: fstC
    G |- fst t : A2

    G |- t : A x B1 && B1 ~ B2
    -------------------------- :: sndC
    G |- snd t : B2

% Annotated Siek16:

    G |- t : A && A ~ B
    ------------------- :: cast
    G |- < B > t : B

defns
  Reduction :: '' ::=

defn
    G |- t1 ~> t2  : A :: :: red :: rd_    {{ com [[t1]] reduces to [[t2]] with type [[A]] in context [[G]] }}
by

    G |- s : A
    --------------- :: values
    G |- s ~> s : A

    G |- t : C
    ------------------------------- :: retracT
    G |- unbox C (box C t) ~> t : C

    G |- t : S
    ---------------------------------- :: retractU
    G |- split S (squash S t) ~> t : S

    G, x : A1 |- t2 : A2 && G |- t1 : A1    
    ------------------------------------ :: beta
    G |- (\x:A1.t2) t1 ~> [t1/x]t2 : A2

    G |- t : A1 -> A2 && x nin FV(t)
    -------------------------------- :: eta
    G |- \x:A1.H(t x) ~> t : A1 -> A2

    G |- t1 : A1 && G |- t2 : A2
    ---------------------------- :: proj1
    G |- fst (t1, t2) ~> t1 : A1

    G |- t1 : A1 && G |- t2 : A2
    ---------------------------- :: proj2
    G |- snd (t1, t2) ~> t2 : A2

    G |- t : A1 x A2
    ---------------------------------- :: etaP
    G |- (fst t, snd t) ~> t : A1 x A2

    G, x : A1 |- t ~> t' : A2
    ---------------------------------- :: lam
    G |- \x:A1.t ~> \x:A1.t' : A1 -> A2

    G |- t1 ~> t'1 : A1 -> A2 && G |- t2 : A1
    ---------------------------------------- :: app1
    G |- t1 t2 ~> t'1 t2 : A2

    G |- t1 : A1 -> A2 && G |- t2 ~> t'2 : A1
    ---------------------------------------- :: app2
    G |- t1 t2 ~> t1 t'2 : A2

    G |- t ~> t' : A1 x A2
    ------------------------- :: fst
    G |- fst t ~> fst t' : A1

    G |- t ~> t' : A1 x A2
    ------------------------- :: snd
    G |- snd t ~> snd t' : A2

    G |- t1 ~> t'1 : A1 && G |- t2 : A2
    ----------------------------------- :: pair1
    G |- (t1,t2) ~> (t'1,t2) : A1 x A2

    G |- t1 : A1 && G |- t2  ~> t'2 : A2
    ------------------------------------ :: pair2
    G |- (t1,t2) ~> (t1,t'2) : A1 x A2

defn
    G |- t1 ~> t2 : A :: :: redA :: rdA_ {{com Reduction for annotated Siek16}}
by
    % Values:

    G |- v : A
    --------------- :: values
    G |- v ~> v : A

    % Casting:

    G |- drop-cast v : C
    ----------------------------- :: castA
    G |- <C> v ~> drop-cast v : C

    G |- t : Nat
    --------------------------------------- :: castNat
    G |- <Nat>(succ t) ~> succ <Nat>t : Nat

    G |- t : A1 -> B1 && (A1 -> B1) ~ (A2 -> B2)
    ----------------------------------------------------- :: castArrow
    G |- <A2 -> B2>t ~> \y : A2.<B2> (t <A1>y) : A2 -> B2

    G |- t : A1 x B1 && (A1 x B1) ~ (A2 x B2)
    ------------------------------------------------------ :: castPair
    G |- <A2 x B2>t ~> (<A2>(fst t),<B2>(snd t)) : A2 x B2

    G |- t1 ~> t2 : A && A ~ B
    -------------------------- :: cast
    G |- <B>t1 ~> <B>t2 : B

    % Functions:

    G, x : A1 |- t2 : A2 && G |- t1 : A1    
    ------------------------------------ :: beta
    G |- (\x:A1.t2) t1 ~> [t1/x]t2 : A2

    G |- t : A1 -> A2 && x nin FV(t)
    -------------------------------- :: eta
    G |- \x:A1.H(t x) ~> t : A1 -> A2

    G, x : A1 |- t ~> t' : A2
    ---------------------------------- :: lam
    G |- \x:A1.t ~> \x:A1.t' : A1 -> A2

    G |- t1 ~> t'1 : A1 -> A2 && G |- t2 : A1
    ---------------------------------------- :: app1
    G |- t1 t2 ~> t'1 t2 : A2

    G |- t1 : A1 -> A2 && G |- t2 ~> t'2 : A1
    ---------------------------------------- :: app2
    G |- t1 t2 ~> t1 t'2 : A2

    % Pairs:
    
    G |- t ~> t' : A1 x A2
    ------------------------- :: fst
    G |- fst t ~> fst t' : A1

    G |- t ~> t' : A1 x A2
    ------------------------- :: snd
    G |- snd t ~> snd t' : A2

    G |- t : A1 x A2
    ---------------------------------- :: etaP
    G |- (fst t, snd t) ~> t : A1 x A2
    
    G |- t1 ~> t'1 : A1 && G |- t2 : A2
    ----------------------------------- :: pair1
    G |- (t1,t2) ~> (t'1,t2) : A1 x A2

    G |- t1 : A1 && G |- t2  ~> t'2 : A2
    ------------------------------------ :: pair2
    G |- (t1,t2) ~> (t1,t'2) : A1 x A2

defn
    G |- t1 => t2 : A :: :: castIn :: ci_ {{com Cast insertion from Siek16}}
    {{tex [[G]] \vdash [[t1]] \Rightarrow [[t2]] : [[A]] }}
by

    x : A elem G
    --------------- :: var
    G |- x => x : A

    --------------- :: zero
    G |- 0 => 0 : A

    --------------------- :: triv
    G |- triv => triv : A

    G |- t1 => t2 : Nat
    ----------------------------- :: succ
    G |- succ t1 => succ t2 : Nat

    G |- t1 => t3 : A1 && G |- t2 => t4 : A2
    ---------------------------------------- :: pair
    G |- (t1,t2) => (t3,t4) : A1 x A2

    (G |- t1 => t2 : A1 x B && A1 ~ A2) && A1 != A2
    ----------------------------------------------- :: fst1
    G |- fst t1 => fst <A2 x B>t2 : A2

    G |- t1 => t2 : A x B
    ------------------------- :: fst2
    G |- fst t1 => fst t2 : A

    (G |- t1 => t2 : A x B1 && B1 ~ B2) && B1 != B2
    ----------------------------------------------- :: snd1
    G |- snd t1 => snd <A x B2>t2 : B2

    G |- t1 => t2 : A x B
    ------------------------- :: snd2
    G |- snd t1 => snd t2 : B

    G, x : A1 |- t1 => t2 : A2
    ------------------------------------ :: lam
    G |- \x:A1.t1 => \x:A1.t2 : A1 -> A2

    G |- t1 => t3 : ? && G |- t2 => t4 : A
    -------------------------------------- :: app1
    G |- t1 t2 => (<A -> ?>t3) t4 : ?

    G |- t1 => t3 : A1 -> B 
    (G |-t2 => t4 : A2 && A1 ~ A2) && A1 != A2
    ------------------------------------------ :: app2
    G |- t1 t2 => t1 <A1>t: B

    G |- t1 => t3 : A1 -> A2 && G |- t2 => t4 : A1
    ---------------------------------------------- :: app3
    G |- t1 t2  => t3 t4 : A2

    G |- t1 => t2 : ?
    ----------------------------------- :: succU
    G |- succ t1 => <?>succ <Nat>t2 : ?

    G |- t1 => t2 : ?
    -------------------------------- :: fstU
    G |- fst t1 => fst <? x ?>t2 : ?

    G |- t1 => t2 : ?
    -------------------------------- :: sndU
    G |- snd t1 => snd <? x ?>t2 : ?