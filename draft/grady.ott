                  % -*- compile-command: "make" -*-

metavar termvar, x, z ::=

indexvar index, k ::=

grammar
  t :: 't_' ::=                                {{ com term }}
    | x                   ::   :: var          {{ com variable }}
    | triv                ::   :: unit         {{ com unit }}
    | squash              ::   :: inj          {{ com injection of the retract }}
    {{tex \mathsf{squash} }}
    | split               ::   :: surj         {{ com surjection of the retract }}
    {{tex \mathsf{split} }}
    | box t               ::   :: gen          {{ com generalize to the untyped universe }}
    {{tex \mathsf{box}\,[[t]] }}
    | unbox T             ::   :: spec         {{ com specialize the untyped universe to a specific type }}
    {{tex \mathsf{unbox}_{[[T]]} }}
    | \ x : A . t         ::   :: abs          {{ com $\lambda$-abstraction }}
    {{tex \lambda [[x]] : [[A]] . [[t]] }}
    | t1 t2               ::   :: app          {{ com function application }}
    | ( t1 , t2 )         ::   :: pair         {{ com pair constructor }}
    | fst t               ::   :: proj1        {{ com first projection }}
    {{tex \mathsf{fst}\,[[t]] }}
    | snd t               ::   :: proj2        {{ com second projection }}
    {{tex \mathsf{snd}\,[[t]] }}
    | succ t              ::   :: successor    {{ com successor function }}
    | 0                   ::   :: zero         {{ com zero }}
    | ( t )               :: S :: parens
    | [ t1 / x ] t2       :: M :: subst
    | wrong               :: M :: wrong
    {{tex \mathsf{wrong} }}
    | h( t )              :: M :: hparens
    {{tex [[t]] }}
    
  T :: 'T_' ::=                                {{ com terminating types }}  
    | Unit                ::   :: unit         {{ com unit type }}
    | Nat                 ::   :: nat          {{ com natural number type }}
    | T1 -> T2            ::   :: arrow        {{ com function type }}
    | T1 x T2             ::   :: Pairs        {{ com cartesian product type }}
    {{tex [[T1]] \times [[T2]] }} 
    | ( T )               :: S :: paren

  A :: 'A_' ::=                                {{ com type }}  
    | T                   ::   :: term         {{ com terminating type }}
    | ?                   ::   :: unitype      {{ com untyped universe }}
    | A1 -> A2            ::   :: arrow        {{ com function type }}
    | ( A )               :: S :: paren
    | TypeError           :: M :: typeError
    {{tex \mathsf{TypeError} }}

  G {{ tex \Gamma }} :: G_ ::=                 {{ com typing context }}
    | .                   ::   :: em           {{ com empty context }}
    | G , x : A           ::   :: vn           {{ com cons }}
    | G , G'              :: M :: append       {{ com append }}

  terminals :: 'terminals_' ::=
    |  ->                 ::   :: arrow
      {{tex \rightarrow }}
    | |-                  ::   :: turnstile
      {{tex \vdash }}
    | Unit                ::   :: unit
      {{tex 1 }}
    | Nat                 ::   :: nat
    {{tex \mathbb{N} }}
    | succ                ::   :: succ
    {{tex \mathsf{succ} }}
    | ?                   ::   :: unitype
    | .                   ::   :: emptyCtx    
    {{tex \cdot }}
    | ~                   ::   :: cons
    {{tex \sim }}
    | ~U                  ::   :: conv
    {{tex \sim_U }}    
    | elem                ::   :: elem
    {{tex \in }}
    | ~>                  ::   :: red
    {{tex \rightsquigarrow }}
    | triv                ::   :: triv
    {{tex \mathsf{triv} }}

  formula :: 'formula_' ::=
    | judgement           ::   :: judgement
    | x : A elem G        ::   :: xTelemG
    | formula1 && formula2 ::  :: Quad
    {{tex [[formula1]] \quad [[formula2]] }}
    | not formula         ::   :: not
    | ( formula )         :: S :: parens
    {{tex [[formula]] }}
    | x nin FV ( t )      :: M :: FV
    {{tex [[x]] \not\in \mathsf{FV}([[t]]) }}
    | t != t'             :: M :: NeqT
    {{tex [[t]] \neq [[t']] }}

defns
  Typing :: '' ::=

defn
    G |- t : A :: :: type :: ''    {{ com [[t]] has type [[A]] in context [[G]] }} by

    x : A elem G
    ------------ :: var
    G |- x : A

    G |- t : T
    ------------------- :: Box
    G |- box t : ?

    --------------------- :: Unbox
    G |- unbox T : ? -> T

    --------------------------- :: inj
    G |- squash : (? -> ?) -> ?

    -------------------------- :: surj
    G |- split : ? -> (? -> ?)

    ---------------- :: unit
    G |- triv : Unit

    ------------- :: zero
    G |- 0 : Nat

    G |- t : Nat
    ----------------- :: succ
    G |- succ t : Nat

    G |- t1 : T1 && G |- t2 : T2
    ---------------------------- :: pair
    G |- (t1,t2) : T1 x T2

    G |- t : T1 x T2
    ---------------- :: fst
    G |- fst t : T1

    G |- t : T1 x T2
    ---------------- :: snd
    G |- snd t : T2

    G, x : A1 |- t : A2
    ----------------------- :: lam
    G |- \x:A1.t : A1 -> A2

    G |- t1 : A1 -> A2 && G |- t2 : A1
    ---------------------------------- :: app
    G |- t1 t2 : A2

defns
  Reduction :: '' ::=

defn
    G |- t1 ~> t2  : A :: :: red :: rd_    {{ com [[t1]] reduces to [[t2]] with type [[A]] in context [[G]] }}
by

    G |- t : T
    ------------------------------- :: retracT
    G |- unbox T (box t) ~> t : T

    t != box t'
    ----------------------------------- :: unboxErr
    G |- unbox T t ~> wrong : TypeError 

    G |- t : ? -> ?
    ----------------------------------- :: retractU
    G |- split (squash t) ~> t : ? -> ?

    G |- t : A1 -> A2 && x nin FV(t)
    -------------------------------- :: eta
    G |- \x:A1.h(t x) ~> t : A1 -> A2

    G, x : A1 |- t2 : A2 && G |- t1 : A1    
    ------------------------------------ :: beta
    G |- (\x:A1.t2) t1 ~> [t1/x]t2 : A2

    G |- t1 : T1 && G |- t2 : T2
    ---------------------------- :: proj1
    G |- fst (t1, t2) ~> t1 : T1

    G |- t1 : T1 && G |- t2 : T2
    ---------------------------- :: proj2
    G |- snd (t1, t2) ~> t2 : T2

    G |- t : T1 x T2
    ---------------------------------- :: etaP
    G |- (fst t, snd t) ~> t : T1 x T2

    G, x : A1 |- t ~> t' : A2
    ---------------------------------- :: lam
    G |- \x:A1.t ~> \x:A1.t' : A1 -> A2

    G |- t1 ~> t'1 : A1 -> A2 && G |- t2 : A1
    ---------------------------------------- :: app1
    G |- t1 t2 ~> t'1 t2 : A2

    G |- t1 : A1 -> A2 && G |- t2 ~> t'2 : A1
    ---------------------------------------- :: app2
    G |- t1 t2 ~> t1 t'2 : A2

    G |- t ~> t' : T1 x T2
    ------------------------ :: fst
    G |- fst t ~> fst t' : T1

    G |- t ~> t' : T1 x T2
    ------------------------ :: snd
    G |- snd t ~> snd t' : T2

    G |- t1 ~> t'1 : T1 && G |- t2 : T2
    ---------------------------------- :: pair1
    G |- (t1,t2) ~> (t'1,t2) : T1 x T2

    G |- t1 : T1 && G |- t2  ~> t'2 : T2
    ----------------------------------- :: pair2
    G |- (t1,t2) ~> (t1,t'2) : T1 x T2