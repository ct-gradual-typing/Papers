

metavar termvar, x, y , z, f ::=
metavar typevar, X, Y , Z ::=
indexvar index, i , j, k ::=

grammar
  t, c, v, s, n :: 't_' ::=                    {{ com term }}
    | x                   ::   :: var          {{ com variable }}
    | triv                ::   :: unit         {{ com unit }}
    {{tex \mathsf{triv} }}
    | squash S            ::   :: inj          {{ com injection of the retract }}
    {{tex \mathsf{squash}_{[[S]]} }}
    | split S             ::   :: surj         {{ com surjection of the retract }}
    {{tex \mathsf{split}_{[[S]]} }}    
    | box C               ::   :: gen          {{ com generalize to the untyped universe }}
    {{tex \mathsf{box}_{[[C]]} }}    
    | unbox C             ::   :: spec         {{ com specialize the untyped universe to a specific type }}
    {{tex \mathsf{unbox}_{[[C]]} }}
    | lbox C               :: M  :: lgen
    {{tex \widehat{\mathsf{box} }_{[[C]]} }}    
    | lunbox C             :: M  :: lspec
    {{tex \widehat{\mathsf{unbox} }_{[[C]]} }}    
    | Box C               :: M  :: lGen
    {{tex \mathsf{Box}_{[[C]]} }}    
    | Unbox C             :: M  :: lSpec
    {{tex \mathsf{Unbox}_{[[C]]} }}
    | Lam X . t           ::    :: TypeLam
    {{tex \Lambda [[X]].[[t]] }}
    | [ A ] t             ::   :: TypeApp
    {{tex [ [[A]] ] [[t]] }}
    | t1 ; t2             :: M :: Comp
    | t1 -> t2            :: M :: Arrow
    | t1 XX t2             :: M :: Prod
    {{tex [[t1]] \times [[t2]] }}
    | lsplit S            :: M  :: lsplit
    {{tex \widehat{\mathsf{split} }_{[[S]]} }}    
    | lsquash S           :: M  :: lsquash
    {{tex \widehat{\mathsf{squash} }_{[[S]]} }}        
    | t : ctag            ::   :: cast         {{ com type cast }}
    {{tex \langle [[t]] : [[ctag]] }}    
    | \ x : A . t         ::   :: abs          {{ com $\lambda$-abstraction }}
    {{tex \lambda [[x]] : [[A]] . [[t]] }}
    | t1 t2               ::   :: app          {{ com function application }}
    | ( t1 , t2 )         ::   :: pair         {{ com pair constructor }}
    | fst t               ::   :: proj1        {{ com first projection }}
    | snd t               ::   :: proj2        {{ com second projection }}
    | succ t              ::   :: successor    {{ com successor function }}
    | 0                   ::   :: zero         {{ com zero }}
    | case t of 0 -> t1 , ( succ x ) -> t2 :: :: natElim
    {{tex \mathsf{case}\,[[t]]\,\mathsf{of}\,0 \to [[t1]], (\mathsf{succ}\,[[x]]) \to [[t2]] }}
    | ( t )               :: S :: parens
    | [ t1 / x ] t2       :: M :: subst
    | wrong               :: M :: wrong
    {{tex \mathsf{wrong} }}
    | H( t )              :: M :: hparens
    {{tex [[t]] }}
    | squash              :: M  :: injU   
    {{tex \mathsf{squash} }}
    | split               :: M  :: surjU
    {{tex \mathsf{split} }}
    | 42                  :: M :: Forty2
    | 3                   :: M :: Three
    | [| t |]             :: M :: Interp
    {{tex \interp{[[t]]} }}
    | [ A / X ] t         :: M :: TypeSub

  % s :: 's_' ::= {{com simple values }}
  %   | x                   ::   :: var  
  %   | triv                ::   :: unit         {{ com unit }}
  %   | 0                   ::   :: zero         {{ com zero }}

  % v :: 'v_' ::= {{com values }}
  %   | x                   ::   :: var
  %   | triv                ::   :: unit         {{ com unit }}
  %   | 0                   ::   :: zero         {{ com zero }}
  %   | <?> s               ::   :: cast         {{ com untype cast }}
    
  h :: 'h_' ::= {{com head-normal forms}}
    | triv       :: :: triv
    | split S    :: :: split
    | squash S   :: :: squash
    | box C      :: :: box
    {{tex \mathsf{box}_{[[C]]} }}    
    | unbox C    :: :: unbox
    {{tex \mathsf{unbox}_{[[C]]} }}    
    | \ x : A . t :: :: abs
    {{tex \lambda [[x]] : [[A]] . [[t]] }}
    | ( t1 , t2 )  :: :: pair
    | fst t      :: :: fst
    | snd t      :: :: snd
    | succ t     :: :: suc
    | 0          :: :: zero

  T :: 'T_' ::=                                {{ com terminating types }}  
    | Unit                ::   :: unit         {{ com unit type }}
    {{tex \mathsf{Unit} }}
    | Nat                 ::   :: nat          {{ com natural number type }}
    
  % S :: 'S_' ::=
  %   | ? -> ?        ::   :: arrow
  %   | ? x ?         ::   :: prod
  %   | H( S )        :: M :: hparen
  %   {{tex [[S]] }}
  %   | ( S )         :: M :: Paren

  % C :: 'C_' ::=                                {{ com atomic type }}  
  %   | Unit                ::   :: term         {{ com unit type }}
  %   {{tex 1}}
  %   | Nat                 ::   :: nat          {{ com natural number type }}
  %   {{tex \mathsf{Nat} }}

  K :: 'K_' ::=
    | * :: :: TypeOfTypes
    {{tex \star }}  

 ctag :: 'ct_' ::=
    | { A } :: :: Type
    | ctag => ctag' :: :: cast
    {{tex [[ctag]] \Rightarrow [[ctag']] }}
    | h( ctag ) :: :: hparens
    {{tex [[ctag]] }}

  % (Siek) T is an atomic type
  % (Siek) R is either T or ? -> ?
  A, B, C, D, E, S, U, R :: 'A_' ::=                                {{ com type }}
    | X                   ::   :: Var
    | Unit                ::   :: term         {{ com unit type }}
    {{tex \mathsf{Unit} }}
    | 1                   ::   :: terminal
    {{tex 1}}
    | Nat                 ::   :: nat          {{ com natural number type }}
    {{tex \mathsf{Nat} }}    
    | ?                   ::   :: unitype      {{ com untyped universe }}
    | A1 -> A2            ::   :: arrow        {{ com function type }}
    | A1 x A2             ::   :: pair         {{ com cartesian product type }}
    {{tex [[A1]] \times [[A2]] }}     
    | ( A )               :: S :: paren
    | TypeError           :: M :: typeError
    {{tex \mathsf{TypeError} }}
    | H( A )              :: M :: hparen
    {{tex [[A]] }}
    | A1 --> A2           :: M :: Morph
    {{tex [[A1]] \mto [[A2]] }}
    | [| G |]             :: M :: InterpCtx
    {{tex \interp{[[G]]} }}
    | [| A |]             :: M :: InterpType
    {{tex \interp{[[A]]} }}
    | skeleton A          :: M :: Skeleton
    {{tex \mathsf{skeleton}\,[[A]] }}
    | [ A / X ] B         :: M :: TypeSub


  G {{ tex \Gamma }} :: G_ ::=                 {{ com typing context }}
    | .                   ::   :: emptyCtx     {{ com empty context }}
    {{tex \cdot }}
    | G , X : *           ::   :: tvn
    {{tex [[G]],[[X]]:\star }}
    | G , x : A           ::   :: vn           {{ com cons }}
    | G , G'              :: M :: append       {{ com append }}
    | ( G )               :: M :: parens

  terminals :: 'terminals_' ::=
    |  ->                 ::   :: arrow
    {{tex \rightarrow }}
    | |-                  ::   :: turnstile
    {{tex \vdash }}
    | |~                  ::   :: ndash
    {{tex \not \vdash }}    
    | succ                ::   :: succ
    {{tex \mathsf{succ} }}
    | ?                   ::   :: unitype
    | ~                   ::   :: cons
    {{tex \sim }}
    | ~U                  ::   :: conv
    {{tex \sim_U }}    
    | elem                ::   :: elem
    {{tex \in }}
    | ~>                  ::   :: red
    {{tex \rightsquigarrow }}
    | box        :: :: box
    {{tex \mathsf{box} }}
    | unbox        :: :: unbox
    {{tex \mathsf{unbox} }}
    | fst        :: :: fst
    {{tex \mathsf{fst} }}
    | snd        :: :: snd
    {{tex \mathsf{snd} }}                

  vd :: 'vd_' ::=
    | |- :: :: vdash
    | |~ :: :: ndash

  formula :: 'formula_' ::=
    | judgement           ::   :: judgement
    | ~ formula           ::   :: notj
    {{tex \lnot [[formula]] }}
    | x : A elem G        ::   :: xTelemG
    | X : * elem G        ::   :: XTelemG
    {{tex [[X]] : \star \in [[G]] }}
    | formula1 && formula2 ::  :: Quad
    {{tex [[formula1]] \quad [[formula2]] }}
    | not formula         ::   :: not
    | ( formula )         :: S :: parens
    {{tex [[formula]] }}
    | x nin FV ( t )      :: M :: FV
    {{tex [[x]] \not\in \mathsf{FV}([[t]]) }}
    | t != t'             :: M :: NeqT
    {{tex [[t]] \neq [[t']] }}
    | t : A               :: M :: TermHasType
    | A1 != A2            :: M :: TypeNEq
    {{tex [[A1]] \neq [[A2]] }}
    | nat( A ) = B        :: M :: natFun
    {{tex \mathsf{nat}([[A]]) = [[B]] }}
    | fun( A ) = B        :: M :: funFun
    {{tex \mathsf{fun}([[A]]) = [[B]] }}
    | prod( A ) = B       :: M :: prodFun
    {{tex \mathsf{prod}([[A]]) = [[B]] }}    

subrules
  h <:: t
  T <:: A
  
defns
  Typing :: '' ::=

defn
   G |- A : * :: :: kind :: 'K_'
   {{tex [[G]] \vdash [[A]] : \star }} by

   X : * elem G
   ------------ :: var
   G |- X : *

   ------------- :: unit
   G |- Unit : *

   ------------ :: nat
   G |- Nat : *

   ---------- :: unitype
   G |- ? : *

   G |- A : * && G |- B : *
   ------------------------ :: arrow
   G |- A -> B : *

   G |- A : * && G |- B : *
   ------------------------ :: prod
   G |- A x B : *

defn
    G Ok :: :: ctxOk :: 'Ok_'
    {{tex [[G]]\,\text{Ok} }} by

   ---- :: empty
   . Ok

   G Ok
   ----------- :: typeVar
   (G, X : *) Ok

   G Ok && G |- A : *
   ------------------ :: var
   (G, x : A) Ok

defn
    A ~ B :: :: typeConsis :: ''    {{ com [[A]] is consistent with [[B]] }}
    {{tex [[A]] \sim [[B]] }} by

    ----- :: refl
    A ~ A

    ----- :: box
    A ~ ?

    ----- :: unbox
    ? ~ A

    A1 ~ A2 && B1 ~ B2
    ------------------- :: arrow
    A1 -> B1 ~ A2 -> B2

    A1 ~ A2 && B1 ~ B2
    ------------------- :: prod
    A1 x B1 ~ A2 x B2
    
defn
    G vd t : A :: :: type :: ''    {{ com [[t]] has type [[A]] in context [[G]] }}
    {{tex [[G]] [[vd]] [[t]] : [[A]] }} by
    

    x : A elem G
    ------------ :: var
    G |- x : A

    x : A elem G && G Ok
    -------------------- :: varP
    G |- x : A

    ------------------- :: Box
    G |- box T : T -> ?

    G Ok
    ------------------- :: BoxP
    G |- box T : T -> ?

    --------------------- :: Unbox
    G |- unbox T : ? -> T

    G Ok
    --------------------- :: UnboxP
    G |- unbox T : ? -> T

    ------------------- :: BoxG
    G |- Box A : A -> ?

    --------------------- :: UnboxG
    G |- Unbox A : ? -> A

    ---------------------- :: squash
    G |- squash U : U -> ?

    G Ok
    ---------------------- :: squashP
    G |- squash U : U -> ?

    --------------------- :: split
    G |- split U : ? -> U

    G Ok
    --------------------- :: splitP
    G |- split U : ? -> U

    ---------------- :: unit
    G |- triv : Unit

    G Ok
    ---------------- :: unitP
    G |- triv : Unit

    ------------- :: zero
    G |- 0 : Nat

    G Ok
    ------------- :: zeroP
    G |- 0 : Nat

    G |- t : Nat
    ----------------- :: succ
    G |- succ t : Nat

    G |- t : Nat
    G |- t1 : A && G, x : Nat |- t2 : A
    ------------------------------------------ :: case
    G |- case t of 0 -> t1, (succ x) -> t2 : A

    G |- t1 : A1 && G |- t2 : A2
    ---------------------------- :: pair
    G |- (t1,t2) : A1 x A2

    G |- t : A1 x A2
    ---------------- :: fst
    G |- fst t : A1

    G |- t : A1 x A2
    ---------------- :: snd
    G |- snd t : A2

    G, x : A |- t : B
    --------------------- :: lam
    G |- \x:A1.t : A -> B

    G |- t1 : A -> B && G |- t2 : A
    ---------------------------------- :: app
    G |- t1 t2 : B

% Gradual Siek15:

    G |- t1 : C && fun(C) = A1 -> B1
    G |-t2 : A2 && A2 ~ A1
    -------------------------------- :: appS
    G |- t1 t2 : B1

    (G |- t : B && prod(B) = A1 x A2)
    --------------------------------- :: fstS
    G |- fst t : A1

    (G |- t : B && prod(B) = A1 x A2)
    -------------------------------- :: sndS
    G |- snd t : A2

    G |- t : A && nat(A) = Nat
    -------------------------- :: succS
    G |- succ t : Nat

% Annotated Siek16:

    G |- t : A && A ~ B
    --------------------- :: cast
    G |- (t : {A} => {B}) : B

defns
  Reduction :: '' ::=

defn
    G |- t1 ~> t2  : A :: :: red :: rd_    {{ com [[t1]] reduces to [[t2]] with type [[A]] in context [[G]] }}
by

    G |- s : A
    --------------- :: values
    G |- s ~> s : A

    G |- t : T
    ------------------------------- :: retracT
    G |- unbox T (box T t) ~> t : T

    G |- t : A
    ------------------------------- :: retracTG
    G |- Unbox A (Box A t) ~> t : A

    G |- t : U
    ---------------------------------- :: retractU
    G |- split U (squash U t) ~> t : U

    G |- t ~> t' : Nat
    ---------------------------- :: succ
    G |- succ t ~> succ t' : Nat

    G |- t1 : A && G, x : Nat |- t2 : A
    ------------------------------------------------ :: case0
    G |- case 0 of 0 -> t1, (succ x) -> t2 ~> t1 : A

    G |- t : Nat    
    G |- t1 : A && G, x : Nat |- t2 : A
    ------------------------------------------------------------ :: caseSucc
    G |- case (succ t) of 0 -> t1, (succ x) -> t2 ~> [t/x]t2 : A    

    G |- t ~> t' : Nat    
    G |- t1 : A && G, x : Nat |- t2 : A
    -------------------------------------------------------------------------------- :: case1
    G |- case t of 0 -> t1, (succ x) -> t2 ~> case t' of 0 -> t1, (succ x) -> t2 : A

    G, x : A1 |- t : A2 && G |- v : A1    
    ---------------------------------- :: beta
    G |- (\x:A1.t) v ~> [v/x]t : A2

    G |- t1 : A1 && G |- t2 : A2
    ---------------------------- :: proj1
    G |- fst (t1, t2) ~> t1 : A1

    G |- t1 : A1 && G |- t2 : A2
    ---------------------------- :: proj2
    G |- snd (t1, t2) ~> t2 : A2

    G |- t1 ~> t'1 : A1 -> A2 && G |- t2 : A1
    ----------------------------------------- :: app1
    G |- t1 t2 ~> t'1 t2 : A2

    G |- v : A1 -> A2 && G |- t ~> t' : A1
    -------------------------------------- :: app2
    G |- v t ~> v t' : A2

    G |- t ~> t' : A1 x A2
    ------------------------- :: fst
    G |- fst t ~> fst t' : A1

    G |- t ~> t' : A1 x A2
    ------------------------- :: snd
    G |- snd t ~> snd t' : A2

    G |- t1 ~> t'1 : A1 && G |- t2 : A2
    ----------------------------------- :: pair1
    G |- (t1,t2) ~> (t'1,t2) : A1 x A2

    G |- t1 : A1 && G |- t2  ~> t'2 : A2
    ------------------------------------ :: pair2
    G |- (t1,t2) ~> (t1,t'2) : A1 x A2

defn
    G |- t1 ~> t2 ; A :: :: redA :: rdA_ {{com Reduction for annotated Siek15}}
by
    % Values:

    G |- v : A
    --------------- :: values
    G |- v ~> v ; A

    % Casting:

    G |- v : T
    ---------------------------- :: castId
    G |- v : {T} => {T} ~> v ; T

    G |- v : ?
    ---------------------------- :: castU
    G |- v : {?} => {?} ~> v ; ?

    G |- v : R
    -------------------------------------- :: succeed
    G |- v : h({R} => {?}) => {R} ~> v ; R

    G |- v1 : A1 -> B1 && G |- v2 : A2
    --------------------------------------------------------------------------------------------- :: castArrow
    G |- H((v1 : {A1 -> B1} => {A2 -> B2}) v2) ~> H(H(v1 (v2 : {A2} => {A1})) : {B1} => {B2}) ; B

    ((G |- v : A && A ~ T) && T != R) && T != ?
    --------------------------------------------------- :: castGround
    G |- v : {A} => {?} ~> v : h({A} => {T}) => {?} ; ?

    ((G |- v : ? && A ~ T) && T != R) && T != ?
    --------------------------------------------------- :: castExpand
    G |- v : {?} => {A} ~> v : h({?} => {T}) => {A} ; A

    % Functions:

    G, x : A1 |- t : A2 && G |- v : A1    
    ------------------------------------ :: beta
    G |- (\x:A1.t) v ~> [v/x]t ; A2

    G |- t1 ~> t'1 ; A1 -> A2 && G |- t2 : A1
    ----------------------------------------- :: app1
    G |- t1 t2 ~> t'1 t2 ; A2

    G |- v : A1 -> A2 && G |- t ~> t' ; A1
    -------------------------------------- :: app2
    G |- v t ~> v t' ; A2

    % Pairs:
    
    G |- t ~> t' ; A1 x A2
    ------------------------- :: fst
    G |- fst t ~> fst t' ; A1

    G |- t ~> t' ; A1 x A2
    ------------------------- :: snd
    G |- snd t ~> snd t' ; A2
    
    G |- t1 ~> t'1 ; A1 && G |- t2 : A2
    ----------------------------------- :: pair1
    G |- (t1,t2) ~> (t'1,t2) ; A1 x A2

    G |- t1 : A1 && G |- t2  ~> t'2 ; A2
    ------------------------------------ :: pair2
    G |- (t1,t2) ~> (t1,t'2) ; A1 x A2

defn
    G |- t1 => t2 : A :: :: castIn :: ci_ {{com Cast insertion from Siek16}}
    {{tex [[G]] \vdash [[t1]] \Rightarrow [[t2]] : [[A]] }}
by

    % x : A elem G
    % --------------- :: var
    % G |- x => x : A

    % --------------- :: zero
    % G |- 0 => 0 : A

    % ------------------------ :: triv
    % G |- triv => triv : Unit

    % G |- t1 => t2 : ?
    % ------------------------------------ :: succOne
    % G |- succ t1 => succ ([Nat]t2) : Nat

    % G |- t1 => t2 : Nat
    % ----------------------------- :: succTwo
    % G |- succ t1 => succ t2 : Nat

    % G |- t1 => t3 : A1 && G |- t2 => t4 : A2
    % ---------------------------------------- :: pair
    % G |- (t1,t2) => (t3,t4) : A1 x A2

    % G |- t1 => t2 : A x B
    % ------------------------- :: fstOne
    % G |- fst t1 => fst t2 : A

    % G |- t1 => t2 : A x B
    % ------------------------- :: sndOne
    % G |- snd t1 => snd t2 : B

    % G, x : A1 |- t1 => t2 : A2
    % ------------------------------------ :: lam
    % G |- \x:A1.t1 => \x:A1.t2 : A1 -> A2

    % G |- t1 => t3 : ? && G |- t2 => t4 : A
    % -------------------------------------- :: app1
    % G |- t1 t2 => (<A -> ?>t3) t4 : ?

    % G |- t1 => t3 : A1 -> B 
    % (G |-t2 => t4 : A2 && A1 ~ A2) && A1 != A2
    % ------------------------------------------ :: app2
    % G |- t1 t2 => t1 <A1>t: B

    % G |- t1 => t3 : A1 -> A2 && G |- t2 => t4 : A1
    % ---------------------------------------------- :: app3
    % G |- t1 t2  => t3 t4 : A2

    % G |- t1 => t2 : ?
    % ----------------------------------- :: succU
    % G |- succ t1 => <?>succ <Nat>t2 : ?

    % G |- t1 => t2 : ?
    % -------------------------------- :: fstTwo
    % G |- fst t1 => fst <? x ?>t2 : ?

    % G |- t1 => t2 : ?
    % -------------------------------- :: sndTwo
    % G |- snd t1 => snd <? x ?>t2 : ?