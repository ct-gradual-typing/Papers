Just as the simply typed $\lambda$-calculus corresponds to cartesian
closed categories our categorical model has a corresponding type
theory we call Grady.  It consists of all of the structure found in
the model.  Its syntax is an extension of the syntax for
$\lambda^?_\to$.

\begin{definition}
  \label{def:grady-syntax}
  Syntax for Grady:
  \[
  \begin{array}{c@{\hspace{5pt}}r@{}@{\hspace{5pt}}r@{}@{\hspace{2pt}}l@{}llllllllllll}
    \text{(basic skeletons)} & [[U]] & ::= & [[? -> ?]] \mid [[? x ?]]\\
    \text{(skeletons)}       & [[S]] & ::= & [[?]] \mid [[S1 x S2]] \mid [[S1 -> S2]]\\
    \text{(atomic types)}    & [[C]] & ::= & [[Unit]] \mid [[Nat]]\\
    \text{(terms)}           & [[t]] & ::= & \ldots \mid [[split U]] \mid [[squash U]] \mid [[box C]] \mid [[unbox C]] \mid [[case t of t1 || x.t2]]\\
    \text{(natural numbers)} & [[n]] & ::= & [[0]] \mid [[succ n]]\\
    \text{(simple values)}   & [[s]] & ::= & [[x]] \mid [[triv]] \mid [[n]] \mid [[squash U]] \mid [[split U]] \mid [[box C]] \mid [[unbox C]]\\   
  \end{array}
  \]
\end{definition}
\noindent
The types of Grady are the same as the types of $\lambda^?_\to$
(Definition~\ref{def:gradual-syntax}), in addition, it encompasses all
the terms of $\lambda^?_\to$, and so we do not repeat either of them
here.  The typing rules for Grady can be found in
Figure~\ref{fig:grady-typing} and its reduction rules can be found in
Figure~\ref{fig:grady-reduction}.
\renewcommand{\GradydruleBoxName}{\text{box}}
\renewcommand{\GradydruleUnboxName}{\text{unbox}}
\renewcommand{\GradydruleBoxGName}{\text{Box}}
\renewcommand{\GradydruleUnboxGName}{\text{Unbox}}
\renewcommand{\GradydrulesquashName}{\text{squash}}
\renewcommand{\GradydrulesplitName}{\text{split}}
\renewcommand{\GradydrulecaseName}{[[Nat]]_e}
\begin{figure}
  \begin{mdframed}
    \begin{mathpar}
      \Gradydrulevar{} \and
      \GradydruleBox{} \and
      \GradydruleUnbox{} \and
      \Gradydrulesquash{} \and
      \Gradydrulesplit{} \and
      \Gradydruleunit{} \and
      \Gradydrulezero{} \and
      \Gradydrulesucc{} \and
      \Gradydrulecase{} \and
      \Gradydrulepair{} \and
      \Gradydrulefst{} \and
      \Gradydrulesnd{} \and
      \Gradydrulelam{} \and
      \Gradydruleapp{}
    \end{mathpar}
  \end{mdframed}
  \caption{Typing rules for Grady}
  \label{fig:grady-typing}
\end{figure}
\renewcommand{\GradydrulerdXXvaluesName}{\text{values}} 
\renewcommand{\GradydrulerdXXretracTName}{\text{retract}_1}
\renewcommand{\GradydrulerdXXretracTGName}{\text{retract}_3} 
\renewcommand{\GradydrulerdXXretractUName}{\text{retract}_2} 
\renewcommand{\GradydrulerdXXbetaName}{\beta} 
\renewcommand{\GradydrulerdXXetaName}{\eta} 
\renewcommand{\GradydrulerdXXprojOneName}{\times_{e_1}} 
\renewcommand{\GradydrulerdXXprojTwoName}{\times_{e_2}} 
\renewcommand{\GradydrulerdXXetaPName}{\times_\eta} 
\renewcommand{\GradydrulerdXXlamName}{\to} 
\renewcommand{\GradydrulerdXXappOneName}{\to_{e_1}} 
\renewcommand{\GradydrulerdXXappTwoName}{\to_{e_2}} 
\renewcommand{\GradydrulerdXXfstName}{[[fst]]} 
\renewcommand{\GradydrulerdXXsndName}{[[snd]]} 
\renewcommand{\GradydrulerdXXpairOneName}{\times_1} 
\renewcommand{\GradydrulerdXXpairTwoName}{\times_2}
\renewcommand{\GradydrulerdXXsuccName}{\text{succ}}       
\renewcommand{\GradydrulerdXXcaseZeroName}{[[Nat]]_{e_0}} 
\renewcommand{\GradydrulerdXXcaseSuccName}{[[Nat]]_{e_1}} 
\renewcommand{\GradydrulerdXXcaseOneName}{\text{case}_1} 
\renewcommand{\GradydrulerdXXcaseTwoName}{\text{case}_2} 
\renewcommand{\GradydrulerdXXcaseThreeName}{\text{case}_3}       
\begin{figure}
  \begin{mdframed}
    \begin{mathpar}
      \GradydrulerdXXvalues{} \and
      \GradydrulerdXXretracT{} \and
      \GradydrulerdXXretractU{} \and
      \GradydrulerdXXbeta{} \and
      \GradydrulerdXXeta{} \and
      \GradydrulerdXXprojOne{} \and
      \GradydrulerdXXprojTwo{} \and
      \GradydrulerdXXetaP{} \and
      \GradydrulerdXXsucc{} \and      
      \GradydrulerdXXcaseZero{} \and
      \GradydrulerdXXcaseSucc{} \and
      \GradydrulerdXXcaseOne{} \and
      \GradydrulerdXXcaseTwo{} \and
      \GradydrulerdXXcaseThree{} \and      
      \GradydrulerdXXlam{} \and      
      \GradydrulerdXXappOne{} \and
      \GradydrulerdXXappTwo{} \and
      \GradydrulerdXXfst{} \and
      \GradydrulerdXXsnd{} \and
      \GradydrulerdXXpairOne{} \and
      \GradydrulerdXXpairTwo{}    
    \end{mathpar}
  \end{mdframed}
  \caption{Reduction rules for Grady}
  \label{fig:grady-reduction}
\end{figure}

Just as we did for the categorical model
(Lemma~\ref{lemma:casting_morphisms}) we can lift $[[box C]]$ and
$[[unbox C]]$ to arbitrary type.
\begin{lemma}[Syntactic $[[Box A]]$ and $[[Unbox A]]$]
  \label{lemma:syntactic_box_and_unbox}
  Given any type $[[A]]$ there are functions $[[Box A]]$ and $[[Unbox
      A]]$ such that the following typing rules are admissible:
  \[
  \begin{array}{lll}
    \GradydruleBoxG{} & \quad & \GradydruleUnboxG{}
  \end{array}
  \]
  Furthermore, the following reduction rule is admissible:
  \[
  \begin{array}{lll}
    \GradydrulerdXXretracTG{} 
  \end{array}
  \]
\end{lemma}
\begin{proof}
  The functions $[[Box A]]$ and $[[Unbox A]]$ can be defined using the
  construction from the categorical model,
  e.g. Definition~\ref{def:boxing-unboxing},
  Definition~\ref{def:lifted-split-squash}, and
  Lemma~\ref{lemma:casting_morphisms}.  However, the categorical
  notions of composition, identity, and the functors $- \to -$ and $-
  \times -$ must be defined as meta-functions first, but after they
  are, then the same constructions apply.  Please see
  Appendix~\ref{subsec:proof_of_interpretation_of_evaluation} for the
  constructions.
\end{proof}
