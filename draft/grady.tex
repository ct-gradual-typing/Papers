Just as the simply typed $\lambda$-calculus corresponds to cartesian
closed categories our categorical model has a corresponding type
theory we call Grady.  It consists of all of the structure found in
the model.  Its syntax is an extension of the syntax for
$\lambda^?_\to$.

\begin{definition}
  \label{def:grady-syntax}
  Syntax for Grady:
  \[
  \begin{array}{c@{\hspace{5pt}}r@{}@{\hspace{5pt}}r@{}@{\hspace{2pt}}l@{}llllllllllll}
    \text{(basic skeletons)} & [[U]] & ::= & [[? -> ?]] \mid [[? x ?]]\\
    \text{(skeletons)}       & [[S]] & ::= & [[?]] \mid [[S1 x S2]] \mid [[S1 -> S2]]\\
    \text{(atomic types)}    & [[C]] & ::= & [[Unit]] \mid [[Nat]]\\
    \text{(terms)}           & [[t]] & ::= & \ldots \mid [[split U]] \mid [[squash U]] \mid [[box C]] \mid [[unbox C]] \mid [[case t of t1 || x.t2]]\\
    \text{(natural numbers)} & [[n]] & ::= & [[0]] \mid [[succ n]]\\
    \text{(simple values)}   & [[s]] & ::= & [[x]] \mid [[triv]] \mid [[n]] \mid [[squash U]] \mid [[split U]] \mid [[box C]] \mid [[unbox C]]\\   
  \end{array}
  \]
\end{definition}
\noindent
The types of Grady are the same as the types of $\lambda^?_\to$
(Definition~\ref{def:gradual-syntax}), in addition, it encompasses all
the terms of $\lambda^?_\to$, and so we do not repeat either of them
here.  The typing rules for Grady can be found in
Figure~\ref{fig:grady-typing} and its reduction rules can be found in
Figure~\ref{fig:grady-reduction}.
\renewcommand{\GradydruleBoxName}{\text{box}}
\renewcommand{\GradydruleUnboxName}{\text{unbox}}
\renewcommand{\GradydruleBoxGName}{\text{Box}}
\renewcommand{\GradydruleUnboxGName}{\text{Unbox}}
\renewcommand{\GradydrulesquashName}{\text{squash}}
\renewcommand{\GradydrulesplitName}{\text{split}}
\renewcommand{\GradydrulecaseName}{[[Nat]]_e}
\begin{figure}
  \begin{mdframed}
    \begin{mathpar}
      \Gradydrulevar{} \and
      \GradydruleBox{} \and
      \GradydruleUnbox{} \and
      \Gradydrulesquash{} \and
      \Gradydrulesplit{} \and
      \Gradydruleunit{} \and
      \Gradydrulezero{} \and
      \Gradydrulesucc{} \and
      \Gradydrulecase{} \and
      \Gradydrulepair{} \and
      \Gradydrulefst{} \and
      \Gradydrulesnd{} \and
      \Gradydrulelam{} \and
      \Gradydruleapp{}
    \end{mathpar}
  \end{mdframed}
  \caption{Typing rules for Grady}
  \label{fig:grady-typing}
\end{figure}
\renewcommand{\GradydrulerdXXvaluesName}{\text{values}} 
\renewcommand{\GradydrulerdXXretracTName}{\text{retract}_1}
\renewcommand{\GradydrulerdXXretracTGName}{\text{retract}_3} 
\renewcommand{\GradydrulerdXXretractUName}{\text{retract}_2} 
\renewcommand{\GradydrulerdXXbetaName}{\beta} 
\renewcommand{\GradydrulerdXXetaName}{\eta} 
\renewcommand{\GradydrulerdXXprojOneName}{\times_{e_1}} 
\renewcommand{\GradydrulerdXXprojTwoName}{\times_{e_2}} 
\renewcommand{\GradydrulerdXXetaPName}{\times_\eta} 
\renewcommand{\GradydrulerdXXlamName}{\to} 
\renewcommand{\GradydrulerdXXappOneName}{\to_{e_1}} 
\renewcommand{\GradydrulerdXXappTwoName}{\to_{e_2}} 
\renewcommand{\GradydrulerdXXfstName}{[[fst]]} 
\renewcommand{\GradydrulerdXXsndName}{[[snd]]} 
\renewcommand{\GradydrulerdXXpairOneName}{\times_1} 
\renewcommand{\GradydrulerdXXpairTwoName}{\times_2}
\renewcommand{\GradydrulerdXXsuccName}{\text{succ}}       
\renewcommand{\GradydrulerdXXcaseZeroName}{[[Nat]]_{e_0}} 
\renewcommand{\GradydrulerdXXcaseSuccName}{[[Nat]]_{e_1}} 
\renewcommand{\GradydrulerdXXcaseOneName}{\text{case}_1} 
\renewcommand{\GradydrulerdXXcaseTwoName}{\text{case}_2} 
\renewcommand{\GradydrulerdXXcaseThreeName}{\text{case}_3}       
\begin{figure}
  \begin{mdframed}
    \begin{mathpar}
      \GradydrulerdXXvalues{} \and
      \GradydrulerdXXretracT{} \and
      \GradydrulerdXXretractU{} \and
      \GradydrulerdXXbeta{} \and
      \GradydrulerdXXeta{} \and
      \GradydrulerdXXprojOne{} \and
      \GradydrulerdXXprojTwo{} \and
      \GradydrulerdXXetaP{} \and
      \GradydrulerdXXsucc{} \and      
      \GradydrulerdXXcaseZero{} \and
      \GradydrulerdXXcaseSucc{} \and
      \GradydrulerdXXcaseOne{} \and
      \GradydrulerdXXcaseTwo{} \and
      \GradydrulerdXXcaseThree{} \and      
      \GradydrulerdXXlam{} \and      
      \GradydrulerdXXappOne{} \and
      \GradydrulerdXXappTwo{} \and
      \GradydrulerdXXfst{} \and
      \GradydrulerdXXsnd{} \and
      \GradydrulerdXXpairOne{} \and
      \GradydrulerdXXpairTwo{}    
    \end{mathpar}
  \end{mdframed}
  \caption{Reduction rules for Grady}
  \label{fig:grady-reduction}
\end{figure}

Just as we did for the categorical model
(Lemma~\ref{lemma:casting_morphisms}) we can lift $[[box C]]$ and
$[[unbox C]]$ to arbitrary type.
\begin{lemma}[Syntactic $[[Box A]]$ and $[[Unbox A]]$]
  \label{lemma:syntactic_box_and_unbox}
  Given any type $[[A]]$ there are functions $[[Box A]]$ and $[[Unbox
      A]]$ such that the following typing rules are admissible:
  \[
  \begin{array}{lll}
    \GradydruleBoxG{} & \quad & \GradydruleUnboxG{}
  \end{array}
  \]
  Furthermore, the following reduction rule is admissible:
  \[
  \begin{array}{lll}
    \GradydrulerdXXretracTG{} 
  \end{array}
  \]
\end{lemma}
\begin{proof}
  The functions $[[Box A]]$ and $[[Unbox A]]$ can be defined using the
  construction from the categorical model,
  e.g. Definition~\ref{def:boxing-unboxing},
  Definition~\ref{def:lifted-split-squash}, and
  Lemma~\ref{lemma:casting_morphisms}.  However, the categorical
  notions of composition, identity, and the functors $- \to -$ and $-
  \times -$ must be defined as meta-functions first, but after they
  are, then the same constructions apply.  Please see
  Appendix~\ref{subsec:proof_of_interpretation_of_evaluation} for the
  constructions.
\end{proof}
\noindent
Perhaps unsurprisingly, due to our results with respect to the
categorical model, we can use the previous result to construct a
type-directed translation of both $\lambda^?_\to$ and
$\lambda^{\langle [[A]] \rangle}_\to$ into Grady.
\begin{lemma}[Translations]
  \label{lemma:translations}
  \begin{center}
    \begin{itemize}
    \item[] 
    \item[i.] If $[[G |- t : A]]$ hold in either $\lambda^?_\to$ or
      $\lambda^{\langle [[A]] \rangle}_\to$, then there exists a term
      $[[t']]$ such that $[[G |- t' : A]]$ holds in Grady.
    \item[ii.] If $[[G |- t1 ~> t2 : A]]$ holds in $\lambda^{\langle [[A]]
      \rangle}_\to$, then $[[G |- t'1 ~> t'2 : A]]$ holds in Grady,
      where $[[G |- t'1 : A]]$ and $[[G |- t'2 : A]]$ are both the
      corresponding Grady terms.
    \end{itemize}
  \end{center}
\end{lemma}
\begin{proof}
  The proof of this result is similar to the proof that both
  $\lambda^?_\to$ and $\lambda^{\langle [[A]] \rangle}_\to$ can be
  interpreted into the categorical model,
  Theorem~\ref{thm:interpretation_of_typing} and
  Theorem~\ref{thm:interpretation_of_evaluation}, and thus, we do not
  give the full proof.  The proof of part one holds by induction on
  $[[G |- t : A]]$, and using the realization that if $[[A ~ B]]$ for
  some types $[[A]]$ and $[[B]]$ then there are casting terms $[[. |-
      c1 : A -> B]]$ and $[[. |- c2 : B -> A]]$ following the proof of
  Lemma~\ref{lemma:type_consistency_in_the_model}. The proof of part
  two holds by induction on $[[G |- t1 ~> t2 : A]]$ making use of part
  one; it is similar to the proof of
  Theorem~\ref{thm:interpretation_of_evaluation}.
\end{proof}

\subsection{Exploiting the Untyped $\lambda$-Calculus}
\label{subsec:exploiting_the_untyped_lambda-calculus}
Having the untyped $\lambda$-calculus along side the typed
$\lambda$-calculus can be a lot of fun.  This section can be seen from
two perspectives: it gives a number of examples in Grady, and shows
several ways the typed and untyped fragments can be mixed.
\todo[inline]{Michael is writing this section.}
\begin{itemize}
\item Church Encoded Data
\item Y-combinator and the natural number eliminator, e.g. terminating recursion on natural numbers
\item Scott Encoded data, this is not available in terminating type theories
\item Parigot Encoded Data, better efficiency 
\end{itemize}
% subsection exploiting_the_untyped_lambda-calculus (end)

\subsection{Extending Grady with Impredicative Polymorphism}
\label{subsec:extending_grady_with_impredicative_polymorphism}
The simplistic nature of Grady makes it well suited to extend with new
features.  In this section we add polymorphism to Grady extending its
typed fragment to System F \cite{Girard:1989}.
\begin{definition}
  \label{def:poly-grady-syntax}
  The syntax of polymorphic Grady as an extension of Grady's is as
  follows:
  \[
  \begin{array}{c@{\hspace{5pt}}r@{}@{\hspace{5pt}}r@{}@{\hspace{2pt}}l@{}llllllllllll}
    \text{(kinds)}           & [[K]] & ::= & [[*]]\\
    \text{(boxable types)}   & [[C]] & ::= & [[Unit]] \mid [[Nat]] \mid [[X]]\\
    \text{(types)}           & [[A]],[[B]],[[D]],[[E]] & ::= & \ldots \mid [[X]] \mid [[Forall X.A]]\\
    \text{(terms)}           & [[t]] & ::= & \ldots \mid [[Lam X . t]] \mid [[ [A]t ]]\\
    \text{(contexts)}        & [[G]] & ::= & [[.]] \mid [[G,X : *]] \mid [[G,x : A]]\\
  \end{array}
  \]  
\end{definition}
We renamed the atomic type syntactic category to boxable types, and
added type variables to this category.  This will allow generic
functions to treat the incoming data as untyped.  The rules for
kinding and well-formed contexts can be found in
Figure~\ref{fig:poly-grady-kinding} and
Figure~\ref{fig:poly-grady-ctx-ok}.  The typing rules can be found in
Figure~\ref{fig:poly-grady-typing}, but we recount the entire system,
because a number of rules had to be changed to insure that the typing
context is always well formed.
\renewcommand{\GradydruleKXXvarName}{\text{var}}
\renewcommand{\GradydruleKXXunitName}{\text{unit}}
\renewcommand{\GradydruleKXXnatName}{[[Nat]]}
\renewcommand{\GradydruleKXXunitypeName}{[[?]]}
\renewcommand{\GradydruleKXXarrowName}{\to}
\renewcommand{\GradydruleKXXprodName}{\times}
\renewcommand{\GradydruleKXXforallName}{\forall}
\begin{figure}
  \begin{mdframed}
    \begin{mathpar}
      \GradydruleKXXvar{} \and
      \GradydruleKXXunit{} \and
      \GradydruleKXXnat{} \and
      \GradydruleKXXunitype{} \and
      \GradydruleKXXarrow{} \and
      \GradydruleKXXprod{} \and
      \GradydruleKXXforall{}
    \end{mathpar}
  \end{mdframed}
  \caption{Kinding rules for Polymorphic Grady}
  \label{fig:poly-grady-kinding}
\end{figure}
\renewcommand{\GradydruleOkXXemptyName}{\text{empty}} 
\renewcommand{\GradydruleOkXXtypeVarName}{\text{type-var}} 
\renewcommand{\GradydruleOkXXvarName}{\text{var}}
\begin{figure}
  \begin{mdframed}
    \begin{mathpar}
      \GradydruleOkXXempty{} \and
      \GradydruleOkXXtypeVar{} \and
      \GradydruleOkXXvar{}
    \end{mathpar}
  \end{mdframed}
  \caption{Well-formed contexts for Polymorphic Grady}
  \label{fig:poly-grady-ctx-ok}
\end{figure}
\renewcommand{\GradydruleBoxPName}{\text{box}}
\renewcommand{\GradydruleUnboxPName}{\text{unbox}}
\renewcommand{\GradydrulesquashPName}{\text{squash}}
\renewcommand{\GradydrulesplitPName}{\text{split}}
\renewcommand{\GradydrulevarPName}[0]{\text{var}}
\renewcommand{\GradydruleunitPName}[0]{\text{unit}}
\renewcommand{\GradydrulezeroPName}[0]{\text{zero}}
\renewcommand{\GradydruleLamName}[0]{\forall}
\renewcommand{\GradydruletypeAppName}[0]{\forall_e}
\begin{figure}
  \begin{mdframed}
    \begin{mathpar}
      \GradydrulevarP{} \and
      \GradydruleBoxP{} \and
      \GradydruleUnboxP{} \and
      \GradydrulesquashP{} \and
      \GradydrulesplitP{} \and
      \GradydruleunitP{} \and
      \GradydrulezeroP{} \and
      \Gradydrulesucc{} \and
      \Gradydrulecase{} \and
      \Gradydrulepair{} \and
      \Gradydrulefst{} \and
      \Gradydrulesnd{} \and
      \Gradydrulelam{} \and
      \Gradydruleapp{} \and
      \GradydruleLam{} \and
      \GradydruletypeApp{}
    \end{mathpar}
  \end{mdframed}
  \caption{Typing rules for Polymorphic Grady}
  \label{fig:poly-grady-typing}
\end{figure}
\noindent
The evaluation rules require far less changes.
\renewcommand{\GradydrulerdXXtypeBetaName}{\text{type}_\beta}
\renewcommand{\GradydrulerdXXtypeAppName}{\forall_e}
\renewcommand{\GradydrulerdXXLamName}{\forall}
\begin{definition}
  \label{def:poly-grady-eval}
  The evaluation rules of polymorphic Grady
  (Definition~\ref{fig:grady-reduction}) are an extension of Grady's
  by adding the following rules:
  \begin{mathpar}
    \GradydrulerdXXtypeBeta{} \and
    \GradydrulerdXXLam{} \and
    \GradydrulerdXXtypeApp{}
  \end{mathpar}
\end{definition}

% subsection extending_grady_with_impredicative_polymorphism (end)

%%% Local Variables: ***
%%% mode:latex ***
%%% TeX-master: "main.tex"  ***
%%% End: ***
