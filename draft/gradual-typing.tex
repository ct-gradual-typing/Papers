We begin by introducing a slight variation of \cite{Siek:2006}'s
gradually typed functional language.  It has been extended with
product types and natural numbers, and instead of a big-step
call-by-value operational semantics it uses a single-step type
directed full $\beta\eta$-evaluator.  One thing we strive for in this
paper is to keep everything as simple as possible so that the
underlying structure of these languages shines through. In this vein,
the change in evaluation makes it easier to interpret the language
into the categorical model.

\newcommand{\GSTLC}{\lambda^?_\to}
\newcommand{\CGSTLC}{\lambda^{\Rightarrow}_\to}

The syntax of the gradual type system $\GSTLC$ is defined in
the following definition.
\begin{definition}
  \label{def:gradual-syntax}
  Syntax for $\GSTLC$:
    \[
\begin{array}{c@{\hspace{5pt}}r@{}@{\hspace{5pt}}r@{}@{\hspace{2pt}}l@{}llllllllllll}
  \text{(types)} & [[A]],[[B]] & ::=  & [[Unit]] \mid [[Nat]] \mid [[?]] \mid [[A x B]] \mid [[A1 -> A2]]\\
  \text{(terms)} & [[t]] & ::=  & [[x]] \mid [[triv]] \mid [[0]] \mid [[succ t]] \mid [[\x:A.t]]  \mid [[t1 t2]]
                                        \mid [[(t1,t2)]] \mid [[fst t]] \mid [[snd t]] \\
  \text{(contexts)} & [[G]] & ::= & [[.]] \mid [[x : A]] \mid [[G1,G2]]\\
\end{array}
\]
\end{definition}
\noindent
This definition is the base syntax for every language in this paper.
The typing rules are defined in Figure~\ref{fig:gradual-typing} and
the type consistency relation is defined in
Figure~\ref{fig:type-consistency}.  The main changes of the version of
$\GSTLC$ defined here from the original due to \cite{Siek:2006}
is that products and natural numbers have been added.  The definition
of products follows how casting is done for functions. So it allows
casting projections of products, for example, it is reasonable for
terms like $[[\x:(? x ?).(succ (fst x))]]$ to type check.
\renewcommand{\GSiekdruleSXXvarName}[0]{\text{var}}
\renewcommand{\GSiekdruleSXXunitName}[0]{\text{unit}}
\renewcommand{\GSiekdruleSXXzeroName}[0]{\text{zero}}
\renewcommand{\GSiekdruleSXXsuccName}[0]{\text{succ}}
\renewcommand{\GSiekdruleSXXpairName}[0]{\times}
\renewcommand{\GSiekdruleSXXlamName}[0]{\to}
\renewcommand{\GSiekdruleSXXsndName}[0]{\times_{e_2}}
\renewcommand{\GSiekdruleSXXfstName}[0]{\times_{e_1}}
\renewcommand{\GSiekdruleSXXappName}[0]{\to_e}
\begin{figure}  
  \begin{mdframed}
    \small
    \begin{mathpar}
      \GSiekdruleSXXvar{} \and
      \GSiekdruleSXXunit{} \and
      \GSiekdruleSXXzero{} \and
      \GSiekdruleSXXsucc{} \and
      \GSiekdruleSXXpair{} \and
      \GSiekdruleSXXfst{} \and
      \GSiekdruleSXXsnd{} \and
      \GSiekdruleSXXlam{} \and
      \GSiekdruleSXXapp{}     
    \end{mathpar}
  \end{mdframed}
  \caption{Typing rules for $\GSTLC$}
  \label{fig:gradual-typing}
\end{figure}
\renewcommand{\GSiekdrulereflName}[0]{\text{refl}}
\renewcommand{\GSiekdruleboxName}[0]{\text{box}}
\renewcommand{\GSiekdruleunboxName}[0]{\text{unbox}}
\renewcommand{\GSiekdrulearrowName}[0]{\to}
\renewcommand{\GSiekdruleprodName}[0]{\times}
\begin{figure}
  \begin{mdframed}
    \small
    \begin{mathpar}
      \GSiekdrulerefl{} \and
      \GSiekdrulebox{} \and
      \GSiekdruleunbox{} \and
      \GSiekdrulearrow{} \and
      \GSiekdruleprod{}    
  \end{mathpar}
  \end{mdframed}
  \caption{Type Consistency for $\GSTLC$}
  \label{fig:type-consistency}
\end{figure}

We can view gradual typing as a surface language feature much like
type inference, and we give it a semantics by translating it into an
annotated core. \cite{Siek:2006} do just that and give $\GSTLC$
an operational semantics by translating it to a fully annotated core
language called $\CGSTLC$.  Its syntax is
an extension of the syntax of $\GSTLC$
(Definition~\ref{def:gradual-syntax}) where terms are the only
syntactic class that differs, and so we do not repeat the syntax of
types or contexts.
\begin{definition}
  \label{def:annotated-syntax}
  Syntax for $\CGSTLC$:
  \[
  \begin{array}{c@{\hspace{5pt}}r@{}@{\hspace{5pt}}r@{}@{\hspace{2pt}}l@{}llllllllllll}
    \text{(values)}        & [[v]] & ::= & TODO\\
    \text{(terms)}         & [[t]] & ::=  & \ldots \mid [[t : {A} => {B}]]\\
  \end{array}
  \]
\end{definition}
\noindent
The typing rules for $\CGSTLC$ can be
found in Figure~\ref{fig:annotated-typing}, and the reduction rules in
Figure~\ref{fig:annotated-reduction}.
\renewcommand{\GSiekdruleCXXvarName}[0]{\text{var}}
\renewcommand{\GSiekdruleCXXunitName}[0]{\text{unit}}
\renewcommand{\GSiekdruleCXXzeroName}[0]{\text{zero}}
\renewcommand{\GSiekdruleCXXsuccName}[0]{\text{succ}}
\renewcommand{\GSiekdruleCXXpairName}[0]{\times}
\renewcommand{\GSiekdruleCXXlamName}[0]{\to}
\renewcommand{\GSiekdruleCXXsndName}[0]{\times_{e_2}}
\renewcommand{\GSiekdruleCXXfstName}[0]{\times_{e_1}}
\renewcommand{\GSiekdruleCXXappName}[0]{\to_e}
\renewcommand{\GSiekdruleCXXcastName}[0]{\text{cast}}
\begin{figure}
    \begin{mdframed}
    \small
    \begin{mathpar}
      \GSiekdruleCXXvar{} \and
      \GSiekdruleCXXunit{} \and
      \GSiekdruleCXXzero{} \and
      \GSiekdruleCXXsucc{} \and
      \GSiekdruleCXXpair{} \and
      \GSiekdruleCXXfst{} \and
      \GSiekdruleCXXsnd{} \and
      \GSiekdruleCXXlam{} \and
      \GSiekdruleCXXapp{} \and      
      \GSiekdruleCXXcast{}
    \end{mathpar}
  \end{mdframed}
  \caption{Typing rules for $\CGSTLC$}
  \label{fig:annotated-typing}
\end{figure}

\renewcommand{\GSiekdrulerdAXXvaluesName}{\text{values}}
\renewcommand{\GSiekdrulerdAXXcastIdName}{}
\renewcommand{\GSiekdrulerdAXXcastUName}{}
\renewcommand{\GSiekdrulerdAXXsucceedName}{}
\renewcommand{\GSiekdrulerdAXXcastArrowName}{}
\renewcommand{\GSiekdrulerdAXXcastGroundName}{}
\renewcommand{\GSiekdrulerdAXXcastExpandName}{}
\renewcommand{\GSiekdrulerdAXXbetaName}{}
\renewcommand{\GSiekdrulerdAXXappOneName}{}
\renewcommand{\GSiekdrulerdAXXappTwoName}{}
\renewcommand{\GSiekdrulerdAXXfstName}{}
\renewcommand{\GSiekdrulerdAXXsndName}{}
\renewcommand{\GSiekdrulerdAXXpairOneName}{}
\renewcommand{\GSiekdrulerdAXXpairTwoName}{}
\begin{figure}
  TODO
  \caption{Reduction rules for $\CGSTLC$}
  \label{fig:annotated-reduction}
\end{figure}

The major difference from the formalization of $\CGSTLC$ given here
and Siek and Taha's is that it is single step and full
$\beta$-reduction, but it is based on their original definition.

This function is used when casting values to their appropriate type.

Since the formalization of both $\GSTLC$ and $\CGSTLC$ differ
from their original definitions we give the definition of cast
insertion in Figure~\ref{fig:cast-insert}, but this is only a slightly
modified version from the one given by Siek and Taha.
\begin{figure}
  TODO
  \caption{Cast Insertion}
  \label{fig:cast-insert}
\end{figure}


%%% Local Variables: ***
%%% mode:latex ***
%%% TeX-master: "main.tex"  ***
%%% End: ***
