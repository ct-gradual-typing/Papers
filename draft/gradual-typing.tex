We begin by introducing a slight variation of \cite{Siek:2006}'s
gradually typed functional language.  It has been extended with
product types and natural numbers, and instead of a big-step
call-by-value operational semantics it uses a single-step type
directed full $\beta\eta$-evaluator.  One thing we strive for in this
paper is to keep everything as simple as possible so that the
underlying structure of these languages shines through. In this vein,
the change in evaluation makes it easier to interpret the language
into the categorical model.

The syntax of the gradual type system $\lambda^?_\to$ is defined in
the following definition.
\begin{definition}
  \label{def:gradual-syntax}
  Syntax for $\lambda^?_\to$:
    \[
\begin{array}{c@{\hspace{5pt}}r@{}@{\hspace{5pt}}r@{}@{\hspace{2pt}}l@{}llllllllllll}
  \text{(types)} & [[A]],[[B]] & ::=  & [[Unit]] \mid [[Nat]] \mid [[?]] \mid [[A x B]] \mid [[A1 -> A2]]\\
  \\
  \text{(terms)} & [[t]] & ::=  & [[x]] \mid [[triv]] \mid [[0]]       \mid [[succ t]] \mid [[\x:A.t]]  \mid [[t1 t2]]\\
  &                      & \mid & [[(t1,t2)]] \mid [[fst t]] \mid [[snd t]] \\
  \\
  \text{(contexts)} & [[G]] & ::= & [[.]] \mid [[x : A]] \mid [[G1,G2]]\\
\end{array}
\]
\end{definition}
\noindent
This definition is the base syntax for every language in this paper.
The typing rules are defined in Figure~\ref{fig:gradual-typing} and
the type consistency relation is defined in
Figure~\ref{fig:type-consistency}.  The main changes of the version of
$\lambda^?_\to$ defined here from the original due to \cite{Siek:2006}
is that products and natural numbers have been added.  The definition
of products follows how casting is done for functions. So it allows
casting projections of products, for example, it is reasonable for
terms like $[[\x:(? x ?).(succ (fst x))]]$ to type check.
\renewcommand{\GradydrulevarName}[0]{\text{var}}
\renewcommand{\GradydruleunitName}[0]{\text{unit}}
\renewcommand{\GradydrulezeroName}[0]{\text{zero}}
\renewcommand{\GradydrulesuccName}[0]{\text{succ}}
\renewcommand{\GradydrulepairName}[0]{\times}
\renewcommand{\GradydrulefstName}[0]{\times_{e_1}}
\renewcommand{\GradydrulesndName}[0]{\times_{e_2}}
\renewcommand{\GradydrulefstCName}[0]{\times_{e_1}}
\renewcommand{\GradydrulesndCName}[0]{\times_{e_2}}
\renewcommand{\GradydrulelamName}[0]{\to}
\renewcommand{\GradydrulesndUName}[0]{\times^?_{e_2}}
\renewcommand{\GradydrulefstUName}[0]{\times^?_{e_1}}
\renewcommand{\GradydrulesuccUName}[0]{\text{succ}^?}
\renewcommand{\GradydruleappCName}[0]{\to_e}
\renewcommand{\GradydruleappUName}[0]{\to_e^?}
\begin{figure}  
  \begin{mdframed}
    \small
    \begin{mathpar}
      \Gradydrulevar{} \and
      \Gradydruleunit{} \and
      \Gradydrulezero{} \and
      \Gradydrulesucc{} \and
      \Gradydrulepair{} \and
      \GradydrulefstC{} \and
      \GradydrulesndC{} \and
      \Gradydrulelam{} \and
      \GradydruleappC{} \and      
      \GradydrulesuccU{} \and
      \GradydrulefstU{} \and
      \GradydrulesndU{} \and
      \GradydruleappU{}       
    \end{mathpar}
  \end{mdframed}
  \caption{Typing rules for $\lambda^?_\to$}
  \label{fig:gradual-typing}
\end{figure}
\begin{figure}
  \renewcommand{\GradydrulereflName}[0]{\text{refl}}
  \renewcommand{\GradydruleboxName}[0]{\text{box}}
  \renewcommand{\GradydruleunboxName}[0]{\text{unbox}}
  \renewcommand{\GradydrulearrowName}[0]{\to}
  \renewcommand{\GradydruleprodName}[0]{\times}
  \begin{mdframed}
    \small
    \begin{mathpar}
      \Gradydrulerefl{} \and
    \Gradydrulebox{} \and
    \Gradydruleunbox{} \and
    \Gradydrulearrow{} \and
    \Gradydruleprod{}    
  \end{mathpar}
  \end{mdframed}
  \caption{Type Consistency for $\lambda^?_\to$}
  \label{fig:type-consistency}
\end{figure}

We can view gradual typing as a surface language feature much like
type inference, and we give it a semantics by translating it into an
annotated core. \cite{Siek:2006} do just that and give $\lambda^?_\to$
an operational semantics by translating it to a fully annotated core
language called $\lambda^{\langle [[A]] \rangle}_\to$.  Its syntax is
an extension of the syntax of $\lambda^?_\to$
(Definition~\ref{def:gradual-syntax}) where terms are the only
syntactic class that differs, and so we do not repeat the syntax of
types or contexts.
\begin{definition}
  \label{def:annotated-syntax}
  Syntax for $\lambda^{\langle [[A]] \rangle}_\to$:
  \[
  \begin{array}{c@{\hspace{5pt}}r@{}@{\hspace{5pt}}r@{}@{\hspace{2pt}}l@{}llllllllllll}
    \text{(simple values)} & [[s]] & ::= & [[x]] \mid [[triv]] \mid [[0]]\\
    \text{(values)}        & [[v]] & ::= & [[s]] \mid [[<?>s]]\\
    \text{(terms)}         & [[t]] & ::=  & \ldots \mid [[< A > t]]\\
  \end{array}
  \]
\end{definition}
\noindent
The typing rules for $\lambda^{\langle [[A]] \rangle}_\to$ can be
found in Figure~\ref{fig:annotated-typing}, and the reduction rules in
Figure~\ref{fig:annotated-reduction}.
\renewcommand{\GradydruleappName}[0]{\to_e}
\renewcommand{\GradydrulecastName}[0]{\text{cast}}
\begin{figure}
    \begin{mdframed}
    \small
    \begin{mathpar}
      \Gradydrulevar{} \and
      \Gradydruleunit{} \and
      \Gradydrulezero{} \and
      \Gradydrulesucc{} \and
      \Gradydrulepair{} \and
      \Gradydrulefst{} \and
      \Gradydrulesnd{} \and
      \Gradydrulelam{} \and
      \Gradydruleapp{} \and      
      \Gradydrulecast{}
    \end{mathpar}
  \end{mdframed}
  \caption{Typing rules for $\lambda^{\langle [[A]] \rangle}_\to$}
  \label{fig:annotated-typing}
\end{figure}
\renewcommand{\GradydrulerdAXXvaluesName}[0]{\text{value}}
\renewcommand{\GradydrulerdAXXcastAName}[0]{\text{value-cast}}
\renewcommand{\GradydrulerdAXXcastNatName}[0]{[[Nat]]\text{-cast}}
\renewcommand{\GradydrulerdAXXcastArrowName}[0]{\to\hspace{-2.5px}\text{-cast}}
\renewcommand{\GradydrulerdAXXcastPairName}[0]{\times\hspace{-1px}\text{-cast}}
\renewcommand{\GradydrulerdAXXcastName}[0]{\text{cast}}
\renewcommand{\GradydrulerdAXXbetaName}[0]{\beta}
\renewcommand{\GradydrulerdAXXetaName}[0]{\eta}
\renewcommand{\GradydrulerdAXXlamName}[0]{\to}
\renewcommand{\GradydrulerdAXXappOneName}[0]{\to_{e_1}}
\renewcommand{\GradydrulerdAXXappTwoName}[0]{\to_{e_2}}
\renewcommand{\GradydrulerdAXXfstName}[0]{\times_{e_1}}
\renewcommand{\GradydrulerdAXXsndName}[0]{\times_{e_2}}
\renewcommand{\GradydrulerdAXXetaPName}[0]{\times_\eta}
\renewcommand{\GradydrulerdAXXpairOneName}[0]{\times_1}
\renewcommand{\GradydrulerdAXXpairTwoName}[0]{\times_2}
\begin{figure}
  \begin{mdframed}
    \small
    \begin{mathpar}
      \GradydrulerdAXXvalues{} \and
      \GradydrulerdAXXcastA{} \and
      \GradydrulerdAXXcastNat{} \and
      \GradydrulerdAXXcastArrow{} \and
      \GradydrulerdAXXcastPair{} \and
      \GradydrulerdAXXcast{} \and
      \GradydrulerdAXXbeta{} \and
      \GradydrulerdAXXeta{} \and
      \GradydrulerdAXXlam{} \and
      \GradydrulerdAXXappOne{} \and
      \GradydrulerdAXXappTwo{} \and
      \GradydrulerdAXXfst{} \and
      \GradydrulerdAXXsnd{} \and
      \GradydrulerdAXXetaP{} \and
      \GradydrulerdAXXpairOne{} \and
      \GradydrulerdAXXpairTwo{}      
    \end{mathpar}
  \end{mdframed}
  \caption{Reduction rules for $\lambda^{\langle [[A]] \rangle}_\to$}
  \label{fig:annotated-reduction}
\end{figure}

The major difference from the formalization of $\lambda^{\langle [[A]]
  \rangle}$ given here and Siek and Taha's is that it is single step
and full $\beta$-reduction, but it is based on their original
definition.  The function $[[drop-cast v]]$ is defined as follows:
\[
\begin{array}{lll}
  [[drop-cast H(<?>s)]] = [[s]]\\
  [[drop-cast s]] = [[s]]
\end{array}
\]
This function is used when casting values to their appropriate type.

Since the formalization of both $\lambda^?_\to$ and $\lambda^{\langle
  [[A]] \rangle}$ differ from their original definitions we give the
definition of cast insertion in Figure~\ref{fig:cast-insert}, but this
is only a slightly modified version from the one given by Siek and
Taha.
\renewcommand{\GradydruleciXXvarName}[0]{\text{var}}
\renewcommand{\GradydruleciXXzeroName}[0]{\text{zero}}
\renewcommand{\GradydruleciXXtrivName}[0]{\text{unit}}
\renewcommand{\GradydruleciXXsuccName}[0]{\text{succ}}
\renewcommand{\GradydruleciXXpairName}[0]{\times}
\renewcommand{\GradydruleciXXfstOneName}[0]{\times^\sim_{e_1}}
\renewcommand{\GradydruleciXXfstTwoName}[0]{\times_{e_1}}
\renewcommand{\GradydruleciXXsndOneName}[0]{\times^\sim_{e_2}}
\renewcommand{\GradydruleciXXsndTwoName}[0]{\times_{e_2}}
\renewcommand{\GradydruleciXXlamName}[0]{\to}
\renewcommand{\GradydruleciXXappOneName}[0]{\to^?_e}
\renewcommand{\GradydruleciXXappTwoName}[0]{\to^\sim_e}
\renewcommand{\GradydruleciXXappThreeName}[0]{\to_e}
\renewcommand{\GradydruleciXXsuccUName}[0]{\text{succ}^?}
\renewcommand{\GradydruleciXXfstUName}[0]{\times^?_{e_1}}
\renewcommand{\GradydruleciXXsndUName}[0]{\times^?_{e_2}}
\begin{figure}
  \begin{mdframed}
    \begin{mathpar}
      \GradydruleciXXvar{} \and
      \GradydruleciXXzero{} \and
      \GradydruleciXXtriv{} \and
      \GradydruleciXXsucc{} \and
      \GradydruleciXXsuccU{} \and      
      \GradydruleciXXpair{} \and
      \GradydruleciXXfstOne{} \and
      \GradydruleciXXfstTwo{} \and
      \GradydruleciXXsndOne{} \and
      \GradydruleciXXsndTwo{} \and
      \GradydruleciXXfstU{} \and
      \GradydruleciXXsndU{} \and      
      \GradydruleciXXlam{} \and
      \GradydruleciXXappOne{} \and
      \GradydruleciXXappTwo{} \and
      \GradydruleciXXappThree{}       
    \end{mathpar}
  \end{mdframed}
  \caption{Cast Insertion}
  \label{fig:cast-insert}
\end{figure}


%%% Local Variables: ***
%%% mode:latex ***
%%% TeX-master: "main.tex"  ***
%%% End: ***
